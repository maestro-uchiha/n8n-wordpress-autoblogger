{
  "name": "2. Publisher (Autoblogger Engine)",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "id": "trigger-pub-001",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "/**\n * AUTOBLOGGER PUBLISHER ENGINE v3.0 (NO GLOBALS)\n * \n * v3.0 Changes:\n * - NO GLOBAL VARIABLES REQUIRED - all API keys stored per-site in Site_Registry\n * - Compatible with n8n Free tier (no Starter plan needed)\n * - All API keys read from site_config object passed by Master Scheduler\n * \n * MIGRATED FROM v2.49:\n * - Humanized prompts: Anti-AI footprint rules (no em-dashes, typical AI phrases)\n * - Adaptive content style based on topic type (listicles, reviews, how-tos, etc.)\n * - Better meta descriptions (no generic \"Explore/Discover\" openers)\n * - Tone from registry sheet is now explicitly prioritized\n * - Images always generated even when AI omits placeholders\n */\n\nfunction parseInput(json) {\n  // v3.0: No globals needed - all API keys come from site_config\n  let site = json.site_config || json.site || json.siteConfig || {};\n  let topicRow = json.topicRow || json.topic_row || json.row || {};\n  if (!site.base_url && json.base_url) site = json;\n  let topic = topicRow.topic || topicRow.keyword || json.topic || json.keyword || '';\n  return { site, topicRow, topic };\n}\n\nconst input = $input.first().json;\nconst { site, topicRow, topic } = parseInput(input);\n\nconst executionLog = [];\nconst debug = {\n  serp_count: 0,\n  serp_provider: 'none',\n  youtube_candidates_count: 0,\n  images_requested: 0,\n  images_uploaded: 0,\n  images_by_provider: {},\n  internal_links_requested: 0,\n  internal_links_inserted: 0,\n  external_links_requested: 0,\n  external_links_inserted: 0,\n  youtube_embeds_requested: 0,\n  youtube_embeds_inserted: 0,\n  categories_requested: [],\n  categories_found: [],\n  notifications: { speedyindex: false, telegram: false, email: false },\n  seo_meta_updated: false,\n  seo_plugins: {},\n  image_errors: [],\n  wp_errors: []\n};\nlet currentStep = '';\n\nif (!topic) return [{ json: { ok: false, error: 'Missing topic', debug: { input } } }];\nif (!site.base_url) return [{ json: { ok: false, error: 'Missing site base_url', debug: { site, input } } }];\n\n// v3.0: API keys from site_config (check for openai_api_key in site)\nconst siteOpenAIKey = site.openai_api_key || '';\nif (!siteOpenAIKey) return [{ json: { ok: false, error: 'CRITICAL: openai_api_key is missing from Site_Registry. Add the column and your API key.', site, topicRow } }];\n\n// Helper to parse boolean from various formats\nfunction parseBool(val, defaultVal = false) {\n  if (val === undefined || val === null || val === '') return defaultVal;\n  if (typeof val === 'boolean') return val;\n  if (typeof val === 'string') {\n    const lower = val.toLowerCase().trim();\n    if (lower === 'true' || lower === 'yes' || lower === '1') return true;\n    if (lower === 'false' || lower === 'no' || lower === '0') return false;\n  }\n  return defaultVal;\n}\n\n// v3.0: Detect email provider from site-level keys\nfunction detectEmailProvider(site) {\n  if (site.email_provider) return site.email_provider.toLowerCase();\n  if (site.resend_api_key) return 'resend';\n  if (site.sendgrid_api_key) return 'sendgrid';\n  if (site.mailgun_api_key && site.mailgun_domain) return 'mailgun';\n  if (site.smtp2go_api_key) return 'smtp2go';\n  return null;\n}\n\n// v3.0: All config from site_config (no globals)\nconst config = {\n  baseUrl: site.base_url.replace(/\\/$/, ''),\n  authMode: (site.auth_mode || 'jwt').toLowerCase(),\n  wpUser: site.wp_user || site.jwt_user || '',\n  wpPassword: site.wp_app_password || '',\n  jwtUser: site.jwt_user || '',\n  jwtPassword: site.jwt_password || '',\n  jwtToken: site.jwt_token || '',\n  jwtTokenEndpoint: site.jwt_token_endpoint || null,\n  postStatus: site.post_status || 'draft',\n  tone: site.tone || 'informative and engaging',\n  minWords: parseInt(site.min_words) || 1500,\n  maxWords: parseInt(site.max_words) || 2500,\n  faqCount: parseInt(site.faq_count) || 5,\n  imagesCount: (() => {\n    const min = parseInt(site.images_min);\n    const max = parseInt(site.images_max);\n    if (!isNaN(min) && !isNaN(max) && min <= max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return site.images_count !== undefined && site.images_count !== '' ? parseInt(site.images_count) : 0;\n  })(),\n  imageProvider: site.image_provider_priority \n    ? site.image_provider_priority.split(',').map(s => s.trim().toLowerCase()).filter(s => s) \n    : 'fal,pexels,openai'.split(',').map(s => s.trim().toLowerCase()).filter(s => s),\n  internalLinksCount: (() => {\n    const min = parseInt(site.internal_links_min);\n    const max = parseInt(site.internal_links_max);\n    if (!isNaN(min) && !isNaN(max) && min <= max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return site.internal_links_count !== undefined && site.internal_links_count !== '' ? parseInt(site.internal_links_count) : 3;\n  })(),\n  externalLinksCount: (() => {\n    const min = parseInt(site.external_links_min);\n    const max = parseInt(site.external_links_max);\n    if (!isNaN(min) && !isNaN(max) && min <= max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return site.external_links_count !== undefined && site.external_links_count !== '' ? parseInt(site.external_links_count) : 5;\n  })(),\n  youtubeCount: (() => {\n    const min = parseInt(site.youtube_embeds_min);\n    const max = parseInt(site.youtube_embeds_max);\n    if (!isNaN(min) && !isNaN(max) && min <= max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return site.youtube_embeds_count !== undefined && site.youtube_embeds_count !== '' ? parseInt(site.youtube_embeds_count) : 1;\n  })(),\n  defaultCategory: site.default_category || '',\n  \n  // Per-site notification controls\n  indexingEnabled: parseBool(site.indexing_enabled, false),\n  telegramEnabled: parseBool(site.telegram_enabled, true),\n  emailEnabled: parseBool(site.email_enabled, false),\n  \n  // v3.0: ALL API KEYS FROM SITE CONFIG (no globals)\n  openaiKey: site.openai_api_key || '',\n  openaiModel: site.openai_model || 'gpt-4o-mini',\n  openaiImageModel: site.openai_image_model || 'dall-e-2',\n  falModel: site.fal_model || 'fal-ai/flux/schnell',\n  googleCseKey: site.google_cse_api_key || '',\n  googleCseCx: site.google_cse_cx || '',\n  serperKey: site.serper_api_key || '',\n  youtubeKey: site.youtube_api_key || '',\n  pexelsKey: site.pexels_api_key || '',\n  falKey: site.fal_api_key || '',\n  speedyIndexKey: site.speedyindex_api_key || '',\n  fastIndexKey: site.fastindex_api_key || '',\n  telegramToken: site.telegram_bot_token || '',\n  telegramChatId: site.telegram_chat_id || '',\n  notificationEmail: site.notification_email || '',\n  emailFrom: site.email_from || 'noreply@autoblogger.local',\n  emailProvider: detectEmailProvider(site),\n  resendApiKey: site.resend_api_key || '',\n  sendgridApiKey: site.sendgrid_api_key || '',\n  mailgunApiKey: site.mailgun_api_key || '',\n  mailgunDomain: site.mailgun_domain || '',\n  smtp2goApiKey: site.smtp2go_api_key || '',\n  topic,\n  tags: topicRow.tags || '',\n  categories: topicRow.categories || topicRow.category || ''\n};\n\ndebug.images_requested = config.imagesCount;\ndebug.internal_links_requested = config.internalLinksCount;\ndebug.external_links_requested = config.externalLinksCount;\ndebug.youtube_embeds_requested = config.youtubeCount;\n\nasync function httpRequest(options) {\n  return await this.helpers.httpRequest(options);\n}\n\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nlet cachedAuthHeaders = null;\n\nasync function getWpAuthHeaders() {\n  if (cachedAuthHeaders) return cachedAuthHeaders;\n  if (config.authMode === 'jwt') {\n    if (config.jwtToken) {\n      const valid = await validateJwtToken.call(this, config.jwtToken);\n      if (valid) {\n        cachedAuthHeaders = { Authorization: `Bearer ${config.jwtToken}` };\n        return cachedAuthHeaders;\n      }\n    }\n    const token = await getJwtToken.call(this);\n    if (token) {\n      cachedAuthHeaders = { Authorization: `Bearer ${token}` };\n      return cachedAuthHeaders;\n    }\n    throw new Error('JWT authentication failed');\n  } else {\n    const creds = Buffer.from(`${config.wpUser}:${config.wpPassword}`).toString('base64');\n    cachedAuthHeaders = { Authorization: `Basic ${creds}` };\n    return cachedAuthHeaders;\n  }\n}\n\nasync function validateJwtToken(token) {\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'POST',\n      url: `${config.baseUrl}/wp-json/jwt-auth/v1/token/validate`,\n      headers: { Authorization: `Bearer ${token}` }\n    });\n    return resp?.data?.status === 200 || resp?.code === 'jwt_auth_valid_token';\n  } catch { return false; }\n}\n\nasync function getJwtToken() {\n  const endpoint = config.jwtTokenEndpoint || `${config.baseUrl}/wp-json/jwt-auth/v1/token`;\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'POST',\n      url: endpoint,\n      body: { username: config.jwtUser, password: config.jwtPassword },\n      headers: { 'Content-Type': 'application/json' }\n    });\n    return resp?.token || null;\n  } catch (e) {\n    throw new Error(`JWT token fetch failed: ${e.message}`);\n  }\n}\n\nasync function wpAuthSanityCheck() {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  const resp = await httpRequest.call(this, {\n    method: 'GET',\n    url: `${config.baseUrl}/wp-json/wp/v2/users/me`,\n    headers: authHeaders\n  });\n  if (!resp?.id) throw new Error('No user ID in response');\n  return { ok: true, user: resp.name || resp.slug };\n}\n\nasync function fetchSerpHints() {\n  // Try Google CSE first, fall back to Serper.dev\n  \n  // Try Google CSE\n  if (config.googleCseKey && config.googleCseCx) {\n    try {\n      const resp = await httpRequest.call(this, {\n        method: 'GET',\n        url: `https://www.googleapis.com/customsearch/v1?key=${config.googleCseKey}&cx=${config.googleCseCx}&q=${encodeURIComponent(config.topic)}&num=10`\n      });\n      const results = (resp?.items || []).map(item => ({ title: item.title, url: item.link, snippet: item.snippet }));\n      if (results.length > 0) {\n        debug.serp_count = results.length;\n        debug.serp_provider = 'google_cse';\n        return results;\n      }\n    } catch (e) {\n      debug.wp_errors.push({ step: 'SERP_GOOGLE_CSE', error: e.message });\n    }\n  }\n  \n  // Fallback to Serper.dev\n  if (config.serperKey) {\n    try {\n      const resp = await httpRequest.call(this, {\n        method: 'POST',\n        url: 'https://google.serper.dev/search',\n        headers: {\n          'X-API-KEY': config.serperKey,\n          'Content-Type': 'application/json'\n        },\n        body: { q: config.topic, num: 10 }\n      });\n      const results = (resp?.organic || []).map(item => ({ \n        title: item.title, \n        url: item.link, \n        snippet: item.snippet \n      }));\n      debug.serp_count = results.length;\n      debug.serp_provider = 'serper';\n      return results;\n    } catch (e) {\n      debug.wp_errors.push({ step: 'SERP_SERPER', error: e.message });\n    }\n  }\n  \n  debug.serp_provider = 'none';\n  return [];\n}\n\nasync function fetchYouTubeCandidates() {\n  if (!config.youtubeKey || config.youtubeCount === 0) return [];\n  try {\n    // Use videoDuration=medium to exclude Shorts (under 4 min)\n    const resp = await httpRequest.call(this, {\n      method: 'GET',\n      url: `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(config.topic)}&type=video&videoDuration=medium&maxResults=15&key=${config.youtubeKey}`\n    });\n    \n    // Filter out any remaining shorts by title\n    const shortsKeywords = ['#shorts', '#short', 'shorts', '60 sec', '30 sec', 'tiktok'];\n    const results = (resp?.items || [])\n      .filter(item => {\n        const title = (item.snippet?.title || '').toLowerCase();\n        return !shortsKeywords.some(kw => title.includes(kw));\n      })\n      .slice(0, 5)\n      .map(item => ({\n        videoId: item.id?.videoId,\n        title: item.snippet?.title || 'Related Video',\n        url: `https://www.youtube.com/watch?v=${item.id?.videoId}`\n      }));\n    \n    debug.youtube_candidates_count = results.length;\n    return results;\n  } catch (e) {\n    debug.wp_errors.push({ step: 'YOUTUBE', error: e.message });\n    return [];\n  }\n}\n\nasync function generateContentJson() {\n  const imagePlaceholderInstructions = config.imagesCount > 0 \n    ? `\\n\\nIMAGE PLACEHOLDERS (REQUIRED):\\nYou MUST include EXACTLY ${config.imagesCount} image placeholder(s) in the content_html.\\nFormat: <!-- WPIMG alt=\"DESCRIPTIVE ALT TEXT HERE\" -->\\nPLACEMENT: Place each image where it would naturally enhance the reader's understanding - after explaining a concept, showing a process, or introducing a new section. Space them throughout the article.\\nEach ALT text must be unique and descriptive of what the image should show.`\n    : '';\n\n  const youtubePlaceholderInstructions = config.youtubeCount > 0 \n    ? `\\n\\nYOUTUBE PLACEHOLDERS (REQUIRED):\\nYou MUST include EXACTLY ${config.youtubeCount} YouTube placeholder(s) in the content_html.\\nFormat: <!-- YTVID context=\"DESCRIPTION OF WHAT VIDEO SHOULD COVER\" -->\\nPLACEMENT: Place each placeholder where a video tutorial, demonstration, or explanation would naturally fit - such as after introducing a technique, explaining a complex concept, or in a how-to section.\\nEach context description should be unique and relate to the surrounding content.`\n    : '';\n\n  const systemPrompt = `You are an expert SEO content writer creating content for a real blog. You MUST respond with ONLY valid JSON, no other text.\n\nOutput JSON schema:\n{\n  \"title\": \"SEO-optimized title\",\n  \"slug\": \"url-friendly-slug\",\n  \"meta_description\": \"150-160 char meta description\",\n  \"focus_keyphrase\": \"main keyword/phrase to rank for\",\n  \"tag_suggestions\": [\"tag1\", \"tag2\"],\n  \"content_html\": \"<p>Full HTML content...</p>\",\n  \"internal_anchor_phrases\": [\"phrase for internal links\"],\n  \"external_anchor_phrases\": [\"phrase for external links\"],\n  \"youtube_anchor_phrases\": [\"phrase near youtube embed spots\"],\n  \"faq_items\": [{\"question\": \"FAQ question?\", \"answer\": \"Answer text\"}]\n}\n\nWRITING STYLE - CRITICAL (Anti-AI Detection):\n- Write like a human blogger, NOT like an AI assistant\n- NEVER use em-dashes (—) - use commas, periods, or \"and\" instead\n- NEVER use these AI-typical words/phrases: \"delve\", \"tapestry\", \"landscape\", \"realm\", \"crucial\", \"pivotal\", \"elevate\", \"leverage\", \"robust\", \"seamless\", \"cutting-edge\", \"game-changer\", \"it's important to note\", \"it's worth mentioning\", \"in today's world\", \"at the end of the day\"\n- AVOID starting sentences with: \"Whether you're...\", \"When it comes to...\", \"In the world of...\", \"As we navigate...\"\n- Use contractions naturally (don't, won't, it's, you're)\n- Vary sentence length - mix short punchy sentences with longer ones\n- Include occasional informal phrases and colloquialisms appropriate to the tone\n- Write in active voice, be direct and specific\n\nMETA DESCRIPTION RULES - CRITICAL:\n- NEVER start with: \"Explore\", \"Discover\", \"Learn\", \"Find out\", \"Uncover\", \"Dive into\", \"Looking for\"\n- Start with action verbs, questions, or direct statements\n- Good examples: \"Your vape coil isn't lasting? Here's why.\", \"5 proven ways to...\", \"The truth about...\", \"Finally understand why...\"\n- Make it compelling and specific, not generic\n- Include the main keyword naturally\n\nADAPTIVE CONTENT STYLE:\nAnalyze the topic and automatically adapt the format:\n- \"Best X\" / \"Top X\" / \"X alternatives\" → Listicle with numbered items, comparison table, pros/cons\n- \"How to\" / \"Guide\" / \"Tutorial\" → Step-by-step format with numbered instructions, tips boxes\n- \"Review\" / \"vs\" / \"comparison\" → Detailed analysis, comparison table, verdict section\n- \"What is\" / \"Explained\" → Educational format with definitions, examples, breakdown sections\n- \"Tips\" / \"Ideas\" / \"Ways to\" → Bullet-heavy format with actionable takeaways\n- General topics → Balanced informative article with good flow\n\nCONTENT STRUCTURE RULES:\n- ABSOLUTELY NO <a> tags or href attributes - links added programmatically later\n- ABSOLUTELY NO URLs in content_html - no example.com, no placeholder links\n- ABSOLUTELY NO \"Learn more\", \"Read more\", \"Click here\" or similar link text\n- NO citations, sources, or references sections\n- Link anchor phrases must appear ONLY in paragraph text (<p>, <li>), NEVER in headings\n\nHTML & FORMATTING:\n- Use proper HTML: h2, h3, p, ul, li, ol, strong, em, table, thead, tbody, tr, th, td\n- INCLUDE AT LEAST ONE DATA TABLE (comparisons, specs, statistics, pros/cons)\n- Tables should have proper thead with th headers and tbody with td cells\n- Include ${config.faqCount} FAQs at the end (also return them in faq_items array)\n- Target ${config.minWords}-${config.maxWords} words\n- NO title in content_html (title goes in the title field)\n- Anchor phrases MUST appear verbatim as plain text in PARAGRAPH content (NOT in headings)\n- focus_keyphrase should appear naturally 3-5 times in the content\n\nTONE (PRIORITY): ${config.tone}\nThe tone setting from the site takes absolute priority. Adapt your language, formality, and style to match this tone while still following all other rules.${imagePlaceholderInstructions}${youtubePlaceholderInstructions}`;\n\n  const userPrompt = `Write a comprehensive blog article about: \"${config.topic}\"\n\nProvide:\\n1. Engaging introduction\\n2. 4-6 main sections with H2 headings\\n3. Subsections with H3 where appropriate\\n4. AT LEAST ONE HTML TABLE with data\\n5. Practical tips and examples\\n6. ${config.faqCount} FAQs at the end (also in faq_items array)\\n7. ${Math.max(3, config.internalLinksCount)} internal_anchor_phrases (phrases that appear in PARAGRAPHS only)\\n8. ${Math.max(3, config.externalLinksCount)} external_anchor_phrases (phrases that appear in PARAGRAPHS only)\\n9. ${Math.max(2, config.youtubeCount)} youtube_anchor_phrases\\n10. focus_keyphrase (main SEO keyword derived from topic)\\n\\nIMPORTANT: All anchor phrases must appear in <p> or <li> tags, NOT in headings.\\n\\nRespond with ONLY the JSON object.`;\n\n  const resp = await httpRequest.call(this, {\n    method: 'POST',\n    url: 'https://api.openai.com/v1/chat/completions',\n    headers: { 'Authorization': `Bearer ${config.openaiKey}`, 'Content-Type': 'application/json' },\n    body: {\n      model: config.openaiModel,\n      messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }],\n      temperature: 0.7,\n      max_tokens: 4500,\n      response_format: { type: 'json_object' }\n    }\n  });\n\n  const content = resp?.choices?.[0]?.message?.content;\n  if (!content) throw new Error('Empty response from OpenAI');\n  const parsed = JSON.parse(content);\n  \n  // Strip any hallucinated links from content_html\n  if (parsed.content_html) {\n    parsed.content_html = parsed.content_html.replace(/<a[^>]*>([^<]*)<\\/a>/gi, '$1');\n    parsed.content_html = parsed.content_html.replace(/href=\"[^\"]*\"/gi, '');\n    parsed.content_html = parsed.content_html.replace(/https?:\\/\\/example\\.com[^\\s<]*/gi, '');\n    parsed.content_html = parsed.content_html.replace(/https?:\\/\\/www\\.example\\.com[^\\s<]*/gi, '');\n  }\n  \n  return parsed;\n}\n\nfunction validateContent(contentJson) {\n  const errors = [];\n  if (!contentJson.title) errors.push('Missing title');\n  if (!contentJson.content_html) errors.push('Missing content_html');\n  if (!contentJson.meta_description) errors.push('Missing meta_description');\n  if (config.imagesCount > 0) {\n    const placeholderMatches = contentJson.content_html.match(/<!-- WPIMG alt=\"[^\"]+\" -->/g) || [];\n    if (placeholderMatches.length < config.imagesCount) {\n      debug.wp_errors.push({ step: 'VALIDATION_WARNING', message: `Image placeholders: wanted ${config.imagesCount}, got ${placeholderMatches.length}` });\n    }\n  }\n  return errors;\n}\n\nasync function generateImage(prompt) {\n  for (const provider of config.imageProvider) {\n    try {\n      let img = null;\n      if (provider === 'openai' && config.openaiKey) {\n        img = await generateImageOpenAI.call(this, prompt);\n      } else if (provider === 'fal' && config.falKey) {\n        img = await generateImageFal.call(this, prompt);\n      } else if (provider === 'pexels' && config.pexelsKey) {\n        img = await fetchImagePexels.call(this, prompt);\n      }\n      if (img) {\n        debug.images_by_provider[provider] = (debug.images_by_provider[provider] || 0) + 1;\n        return { ...img, provider };\n      }\n    } catch (e) {\n      debug.image_errors.push({ provider, prompt: prompt.substring(0, 50), error: e.message });\n    }\n  }\n  return null;\n}\n\nasync function generateImageOpenAI(prompt) {\n  const isDalle3 = config.openaiImageModel === 'dall-e-3';\n  const imageSize = isDalle3 ? '1024x1024' : '512x512';\n  \n  const resp = await httpRequest.call(this, {\n    method: 'POST',\n    url: 'https://api.openai.com/v1/images/generations',\n    headers: { 'Authorization': `Bearer ${config.openaiKey}`, 'Content-Type': 'application/json' },\n    body: {\n      model: config.openaiImageModel,\n      prompt: `Professional blog image: ${prompt}`,\n      n: 1,\n      size: imageSize,\n      response_format: 'b64_json'\n    },\n    timeout: 60000\n  });\n  const b64 = resp?.data?.[0]?.b64_json;\n  if (b64) return { base64: b64, mimeType: 'image/png', provider: 'openai' };\n  return null;\n}\n\nasync function generateImageFal(prompt) {\n  const resp = await httpRequest.call(this, {\n    method: 'POST',\n    url: `https://fal.run/${config.falModel}`,\n    headers: { \n      'Authorization': `Key ${config.falKey}`, \n      'Content-Type': 'application/json' \n    },\n    body: {\n      prompt: `Professional blog image: ${prompt}`,\n      image_size: 'landscape_16_9',\n      num_images: 1\n    },\n    timeout: 60000\n  });\n  const imageUrl = resp?.images?.[0]?.url;\n  if (imageUrl) return { url: imageUrl };\n  return null;\n}\n\nasync function fetchImagePexels(query) {\n  const resp = await httpRequest.call(this, {\n    method: 'GET',\n    url: `https://api.pexels.com/v1/search?query=${encodeURIComponent(query)}&per_page=5`,\n    headers: { 'Authorization': config.pexelsKey }\n  });\n  const photos = resp?.photos || [];\n  if (photos.length > 0) {\n    const photo = photos[Math.floor(Math.random() * photos.length)];\n    return { url: photo.src?.large || photo.src?.original };\n  }\n  return null;\n}\n\nasync function uploadImageToWp(imageData, filename, altText) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  \n  const ext = (imageData.mimeType || 'image/png').includes('png') ? 'png' : \n              (imageData.mimeType || '').includes('webp') ? 'webp' : 'jpg';\n  const fname = `${filename}.${ext}`;\n  \n  // For base64 images (OpenAI) - use /n8n/v1/upload-image\n  if (imageData.base64) {\n    const magicBytes = Buffer.from(imageData.base64, 'base64').slice(0, 4).toString('hex');\n    debug.image_errors.push({ \n      step: 'TRYING_N8N_PLUGIN_BASE64', \n      filename: fname,\n      magic_bytes: magicBytes,\n      base64_length: imageData.base64.length\n    });\n    \n    try {\n      const uploadResp = await httpRequest.call(this, {\n        method: 'POST',\n        url: `${config.baseUrl}/wp-json/n8n/v1/upload-image`,\n        headers: {\n          ...authHeaders,\n          'Content-Type': 'application/json'\n        },\n        body: {\n          base64: imageData.base64,\n          filename: fname,\n          mime_type: imageData.mimeType || 'image/png',\n          alt_text: altText || filename,\n          title: altText || filename\n        },\n        timeout: 45000\n      });\n      \n      if (uploadResp?.id || uploadResp?.success) {\n        debug.image_errors.push({ step: 'N8N_PLUGIN_SUCCESS', id: uploadResp.id, url: uploadResp.url });\n        return { id: uploadResp.id, url: uploadResp.url || uploadResp.source_url };\n      }\n      debug.image_errors.push({ step: 'N8N_PLUGIN_NO_ID', response: JSON.stringify(uploadResp || {}).substring(0, 300) });\n    } catch (e) {\n      const errMsg = e.message || '';\n      debug.image_errors.push({ step: 'N8N_PLUGIN_FAILED', error: errMsg.substring(0, 200) });\n      \n      if (errMsg.includes('rest_no_route') || errMsg.includes('404')) {\n        debug.image_errors.push({ step: 'PLUGIN_NOT_INSTALLED', hint: 'Install n8n-image-upload.php plugin' });\n      }\n    }\n  }\n  \n  // For URL images (fal, pexels) - use /n8n/v1/sideload-image\n  if (imageData.url) {\n    debug.image_errors.push({ step: 'TRYING_N8N_PLUGIN_SIDELOAD', url: imageData.url?.substring(0, 80) });\n    \n    try {\n      const sideloadResp = await httpRequest.call(this, {\n        method: 'POST',\n        url: `${config.baseUrl}/wp-json/n8n/v1/sideload-image`,\n        headers: {\n          ...authHeaders,\n          'Content-Type': 'application/json'\n        },\n        body: {\n          url: imageData.url,\n          filename: fname,\n          alt_text: altText || filename,\n          title: altText || filename\n        },\n        timeout: 45000\n      });\n      \n      if (sideloadResp?.id || sideloadResp?.success) {\n        debug.image_errors.push({ step: 'SIDELOAD_SUCCESS', id: sideloadResp.id, url: sideloadResp.url });\n        return { id: sideloadResp.id, url: sideloadResp.url || sideloadResp.source_url };\n      }\n      debug.image_errors.push({ step: 'SIDELOAD_NO_ID', response: JSON.stringify(sideloadResp || {}).substring(0, 200) });\n    } catch (e) {\n      const errMsg = e.message || '';\n      debug.image_errors.push({ step: 'SIDELOAD_FAILED', error: errMsg.substring(0, 200) });\n      \n      if (errMsg.includes('rest_no_route') || errMsg.includes('404')) {\n        debug.image_errors.push({ step: 'PLUGIN_NOT_INSTALLED_SIDELOAD' });\n      }\n    }\n    \n    // Fallback: Use external URL directly\n    debug.image_errors.push({ step: 'USING_EXTERNAL_URL', url: imageData.url?.substring(0, 80) });\n    return { id: null, url: imageData.url, external: true };\n  }\n  \n  return null;\n}\n\nasync function processImagePlaceholders(contentHtml, titleSlug) {\n  const placeholderRegex = /<!-- WPIMG alt=\"([^\"]+)\" -->/g;\n  const originalMatches = [...contentHtml.matchAll(placeholderRegex)];\n  let featuredImageId = null;\n  let processedHtml = contentHtml;\n  const domain = config.baseUrl.replace(/https?:\\/\\//, '').replace(/\\/$/, '');\n  \n  // ALWAYS distribute images by H2 sections (ignore AI placement)\n  processedHtml = processedHtml.replace(placeholderRegex, '');\n  \n  // Find H2 sections (excluding Conclusion, FAQs, Summary at the end)\n  const h2Regex = /<h2[^>]*>([^<]*)<\\/h2>/gi;\n  const h2Matches = [...processedHtml.matchAll(h2Regex)];\n  \n  const endingSections = ['conclusion', 'faq', 'summary', 'final', 'wrap'];\n  const usableH2s = h2Matches.filter(m => {\n    const title = m[1].toLowerCase();\n    return !endingSections.some(s => title.includes(s));\n  });\n  \n  // Always generate requested number of images (even if AI omitted placeholders)\n  const imagesToPlace = config.imagesCount;\n  if (imagesToPlace > 0 && usableH2s.length > 0) {\n    const startSection = Math.min(1, usableH2s.length - 1);\n    const availableSections = usableH2s.length - startSection;\n    const step = Math.max(1, Math.floor(availableSections / imagesToPlace));\n    \n    const insertPositions = [];\n    for (let i = 0; i < imagesToPlace; i++) {\n      const sectionIdx = Math.min(startSection + i * step, usableH2s.length - 1);\n      const h2Match = usableH2s[sectionIdx];\n      if (h2Match) {\n        insertPositions.push({\n          index: h2Match.index + h2Match[0].length,\n          alt: originalMatches[i] ? originalMatches[i][1] : `${h2Match[1].trim()} - ${config.topic}`\n        });\n      }\n    }\n    \n    insertPositions.sort((a, b) => b.index - a.index);\n    for (const pos of insertPositions) {\n      const placeholder = `<!-- WPIMG alt=\"${pos.alt}\" -->`;\n      processedHtml = processedHtml.slice(0, pos.index) + '\\n\\n' + placeholder + '\\n\\n' + processedHtml.slice(pos.index);\n    }\n  }\n  \n  const matches = [...processedHtml.matchAll(placeholderRegex)];\n  \n  for (let i = 0; i < Math.min(matches.length, config.imagesCount); i++) {\n    const match = matches[i];\n    const altText = match[1];\n    const img = await generateImage.call(this, altText);\n    if (img) {\n      const uploaded = await uploadImageToWp.call(this, img, `${titleSlug}-${i + 1}`, altText);\n      if (uploaded) {\n        debug.images_uploaded++;\n        const imgUrl = uploaded.url;\n        const imgHtml = uploaded.external \n          ? `<figure class=\"wp-block-image\"><img src=\"${imgUrl}\" alt=\"${altText}\" loading=\"lazy\" /></figure>`\n          : `<figure class=\"wp-block-image\"><img src=\"${imgUrl}\" alt=\"${altText} | ${domain}\" loading=\"lazy\" /></figure>`;\n        processedHtml = processedHtml.replace(match[0], imgHtml);\n        if (i === 0 && uploaded.id) featuredImageId = uploaded.id;\n        if (uploaded.external) {\n          debug.image_errors.push({ step: 'USING_EXTERNAL_URL', url: imgUrl.substring(0, 80) });\n        }\n      } else {\n        processedHtml = processedHtml.replace(match[0], '');\n      }\n    } else {\n      processedHtml = processedHtml.replace(match[0], '');\n    }\n  }\n  processedHtml = processedHtml.replace(placeholderRegex, '');\n  return { html: processedHtml, featuredImageId };\n}\n\nfunction isInsideHeading(content, phrase) {\n  const escapedPhrase = phrase.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  const headingRegex = new RegExp(`<h[1-6][^>]*>[^<]*${escapedPhrase}[^<]*</h[1-6]>`, 'i');\n  return headingRegex.test(content);\n}\n\nfunction findSafeLinkPosition(content, phrase) {\n  const escapedPhrase = phrase.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  const safeContextRegex = new RegExp(\n    `(<(?:p|li|td)[^>]*>[^<]*?)(\\\\b${escapedPhrase}\\\\b)([^<]*?</(?:p|li|td)>)`,\n    'i'\n  );\n  return safeContextRegex.test(content) ? safeContextRegex : null;\n}\n\nasync function injectInternalLinks(content, anchorPhrases) {\n  if (config.internalLinksCount === 0 || !anchorPhrases?.length) return content;\n  const authHeaders = await getWpAuthHeaders.call(this);\n  let modifiedContent = content;\n  let inserted = 0;\n  const shuffled = [...anchorPhrases].sort(() => Math.random() - 0.5);\n  \n  for (const phrase of shuffled) {\n    if (inserted >= config.internalLinksCount) break;\n    if (isInsideHeading(modifiedContent, phrase)) continue;\n    \n    const escapedPhrase = phrase.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const inLinkRegex = new RegExp(`<a[^>]*>[^<]*${escapedPhrase}[^<]*</a>`, 'i');\n    const safeRegex = new RegExp(\n      `(<(?:p|li|td)[^>]*>[^<]*?)(\\\\b${escapedPhrase}\\\\b)([^<]*?</(?:p|li|td)>)`,\n      'i'\n    );\n    if (!safeRegex.test(modifiedContent) || inLinkRegex.test(modifiedContent)) continue;\n    try {\n      const searchResp = await httpRequest.call(this, {\n        method: 'GET',\n        url: `${config.baseUrl}/wp-json/wp/v2/posts?search=${encodeURIComponent(phrase)}&per_page=5&status=publish`,\n        headers: authHeaders\n      });\n      if (searchResp?.length > 0) {\n        const post = searchResp[0];\n        modifiedContent = modifiedContent.replace(safeRegex, `$1<a href=\"${post.link}\">$2</a>$3`);\n        inserted++;\n      }\n    } catch (e) {}\n  }\n  debug.internal_links_inserted = inserted;\n  return modifiedContent;\n}\n\nfunction injectExternalLinks(content, anchorPhrases, serpResults) {\n  if (config.externalLinksCount === 0 || !serpResults?.length) return content;\n  let modifiedContent = content;\n  let inserted = 0;\n  const usedUrls = new Set();\n  const usedParagraphIndices = new Set();\n  const shuffledPhrases = [...(anchorPhrases || [])].sort(() => Math.random() - 0.5);\n  const shuffledSerp = [...serpResults].sort(() => Math.random() - 0.5);\n  \n  const paragraphRegex = /<(p|li|td)[^>]*>[\\s\\S]*?<\\/\\1>/gi;\n  const paragraphs = [...modifiedContent.matchAll(paragraphRegex)];\n  const totalParagraphs = paragraphs.length;\n  \n  const minGap = Math.max(2, Math.floor(totalParagraphs / (config.externalLinksCount + 1)));\n  let lastLinkParagraphIdx = -minGap;\n  \n  function getParagraphIndex(position) {\n    for (let i = 0; i < paragraphs.length; i++) {\n      if (position >= paragraphs[i].index && position < paragraphs[i].index + paragraphs[i][0].length) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  \n  function canPlaceLinkAt(paragraphIdx) {\n    if (paragraphIdx < 0) return false;\n    if (usedParagraphIndices.has(paragraphIdx)) return false;\n    if (paragraphIdx - lastLinkParagraphIdx < minGap && inserted > 0) return false;\n    return true;\n  }\n  \n  function tryPlaceLink(phrase, serpItem) {\n    if (isInsideHeading(modifiedContent, phrase)) return false;\n    \n    const escapedPhrase = phrase.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const inLinkRegex = new RegExp(`<a[^>]*>[^<]*${escapedPhrase}[^<]*</a>`, 'i');\n    if (inLinkRegex.test(modifiedContent)) return false;\n    \n    const safeRegex = new RegExp(\n      `(<(?:p|li|td)[^>]*>[^<]*?)(\\\\b${escapedPhrase}\\\\b)([^<]*?</(?:p|li|td)>)`,\n      'gi'\n    );\n    const matches = [...modifiedContent.matchAll(safeRegex)];\n    \n    for (const match of matches) {\n      const paragraphIdx = getParagraphIndex(match.index);\n      if (canPlaceLinkAt(paragraphIdx)) {\n        const before = modifiedContent.substring(0, match.index);\n        const after = modifiedContent.substring(match.index + match[0].length);\n        const replacement = `${match[1]}<a href=\"${serpItem.url}\" target=\"_blank\" rel=\"noopener\">${match[2]}</a>${match[3]}`;\n        modifiedContent = before + replacement + after;\n        usedParagraphIndices.add(paragraphIdx);\n        lastLinkParagraphIdx = paragraphIdx;\n        return true;\n      }\n    }\n    return false;\n  }\n  \n  for (const phrase of shuffledPhrases) {\n    if (inserted >= config.externalLinksCount) break;\n    const serpItem = shuffledSerp.find(s => !usedUrls.has(s.url));\n    if (serpItem && tryPlaceLink(phrase, serpItem)) {\n      usedUrls.add(serpItem.url);\n      inserted++;\n    }\n  }\n  \n  if (inserted < config.externalLinksCount) {\n    const availableSerp = shuffledSerp.filter(s => !usedUrls.has(s.url));\n    const skipWords = ['about', 'their', 'there', 'these', 'those', 'which', 'would', 'could', 'should', 'being', 'after', 'before', 'between', 'through', 'during', 'without', 'within', 'learn', 'click', 'here', 'best', 'guide', 'review', 'ultimate'];\n    \n    function extractNgrams(title, n) {\n      const words = title.split(/[^a-zA-Z0-9]+/).filter(w => w.length >= 3);\n      const ngrams = [];\n      for (let i = 0; i <= words.length - n; i++) {\n        const phrase = words.slice(i, i + n).join(' ');\n        const phraseWords = phrase.toLowerCase().split(' ');\n        if (!phraseWords.some(w => skipWords.includes(w))) {\n          ngrams.push(phrase);\n        }\n      }\n      return ngrams;\n    }\n    \n    for (const serpItem of availableSerp) {\n      if (inserted >= config.externalLinksCount) break;\n      let matched = false;\n      \n      for (const n of [3, 2, 1]) {\n        if (matched) break;\n        const phrases = n === 1 \n          ? serpItem.title.split(/[^a-zA-Z0-9]+/).filter(w => w.length >= 5 && !skipWords.includes(w.toLowerCase()))\n          : extractNgrams(serpItem.title, n);\n        \n        for (const phrase of phrases) {\n          if (tryPlaceLink(phrase, serpItem)) {\n            usedUrls.add(serpItem.url);\n            inserted++;\n            matched = true;\n            break;\n          }\n        }\n      }\n    }\n  }\n  \n  if (inserted < config.externalLinksCount && inserted < totalParagraphs) {\n    const availableSerp = shuffledSerp.filter(s => !usedUrls.has(s.url));\n    for (const serpItem of availableSerp) {\n      if (inserted >= config.externalLinksCount) break;\n      \n      for (let i = 0; i < totalParagraphs; i++) {\n        if (usedParagraphIndices.has(i)) continue;\n        \n        const para = paragraphs[i];\n        const paraText = para[0];\n        \n        const words = paraText.replace(/<[^>]+>/g, '').split(/\\s+/).filter(w => w.length >= 5);\n        for (const word of words) {\n          const cleanWord = word.replace(/[^a-zA-Z0-9]/g, '');\n          if (cleanWord.length < 5) continue;\n          if (tryPlaceLink(cleanWord, serpItem)) {\n            usedUrls.add(serpItem.url);\n            inserted++;\n            break;\n          }\n        }\n        if (usedUrls.has(serpItem.url)) break;\n      }\n    }\n  }\n  \n  debug.external_links_inserted = inserted;\n  return modifiedContent;\n}\n\nasync function injectYouTubeEmbeds(content, anchorPhrases, youtubeCandidates) {\n  if (config.youtubeCount === 0) return content;\n  let modifiedContent = content;\n  let inserted = 0;\n  const usedVideos = new Set();\n  \n  modifiedContent = modifiedContent.replace(/<!-- YTVID context=\"[^\"]+\" -->/g, '');\n  \n  const h2Regex = /<h2[^>]*>([^<]*)<\\/h2>/gi;\n  const h2Matches = [...modifiedContent.matchAll(h2Regex)];\n  \n  const endingSections = ['conclusion', 'faq', 'summary', 'final', 'wrap'];\n  const usableH2s = h2Matches.filter(m => {\n    const title = m[1].toLowerCase();\n    return !endingSections.some(s => title.includes(s));\n  });\n  \n  if (usableH2s.length === 0) {\n    debug.youtube_embeds_inserted = 0;\n    return modifiedContent;\n  }\n  \n  const embedCount = Math.min(config.youtubeCount, usableH2s.length);\n  const midPoint = Math.floor(usableH2s.length / 2);\n  \n  const sectionsForVideos = [];\n  for (let i = 0; i < embedCount; i++) {\n    let sectionIdx;\n    if (embedCount === 1) {\n      sectionIdx = midPoint;\n    } else {\n      sectionIdx = midPoint + (i % 2 === 0 ? Math.floor(i/2) : -Math.ceil(i/2));\n      sectionIdx = Math.max(0, Math.min(sectionIdx, usableH2s.length - 1));\n    }\n    if (!sectionsForVideos.includes(sectionIdx)) {\n      sectionsForVideos.push(sectionIdx);\n    }\n  }\n  \n  const insertPositions = [];\n  for (const sectionIdx of sectionsForVideos) {\n    const h2Match = usableH2s[sectionIdx];\n    if (!h2Match) continue;\n    \n    const sectionTitle = h2Match[1].trim();\n    const searchQuery = `${sectionTitle} ${config.topic}`.substring(0, 100);\n    \n    try {\n      const resp = await httpRequest.call(this, {\n        method: 'GET',\n        url: `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(searchQuery)}&type=video&videoDuration=medium&maxResults=5&key=${config.youtubeKey}`\n      });\n      \n      const shortsKeywords = ['#shorts', '#short', 'shorts', '60 sec', '30 sec', 'tiktok'];\n      const videos = (resp?.items || [])\n        .filter(item => {\n          const title = (item.snippet?.title || '').toLowerCase();\n          return !shortsKeywords.some(kw => title.includes(kw));\n        })\n        .map(item => ({\n          videoId: item.id?.videoId,\n          title: item.snippet?.title || 'Related Video'\n        }));\n      \n      const video = videos.find(v => v.videoId && !usedVideos.has(v.videoId));\n      if (video) {\n        insertPositions.push({\n          index: h2Match.index + h2Match[0].length,\n          video: video,\n          sectionTitle: sectionTitle\n        });\n        usedVideos.add(video.videoId);\n      }\n    } catch (e) {\n      debug.wp_errors.push({ step: 'YOUTUBE_SECTION_SEARCH', section: sectionTitle, error: e.message });\n      if (youtubeCandidates?.length > 0) {\n        const video = youtubeCandidates.find(v => !usedVideos.has(v.videoId));\n        if (video) {\n          insertPositions.push({\n            index: h2Match.index + h2Match[0].length,\n            video: video,\n            sectionTitle: sectionTitle\n          });\n          usedVideos.add(video.videoId);\n        }\n      }\n    }\n  }\n  \n  insertPositions.sort((a, b) => b.index - a.index);\n  for (const pos of insertPositions) {\n    const embedBlock = `\n\nhttps://www.youtube.com/watch?v=${pos.video.videoId}\n\n<p style=\"text-align:center;font-style:italic;color:#666;margin-top:-10px;\">${pos.video.title}</p>\n\n`;\n    modifiedContent = modifiedContent.slice(0, pos.index) + embedBlock + modifiedContent.slice(pos.index);\n    inserted++;\n  }\n  \n  debug.youtube_embeds_inserted = inserted;\n  return modifiedContent;\n}\n\nasync function getOrCreateTags(tagString, tagSuggestions) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  let termNames = [];\n  if (tagString) {\n    termNames = tagString.split(/[,|]/).map(t => t.trim()).filter(t => t);\n  } else if (tagSuggestions?.length) {\n    termNames = tagSuggestions.slice(0, 5);\n  }\n  if (termNames.length === 0) return [];\n  const ids = [];\n  for (const name of termNames) {\n    try {\n      const searchResp = await httpRequest.call(this, {\n        method: 'GET',\n        url: `${config.baseUrl}/wp-json/wp/v2/tags?search=${encodeURIComponent(name)}`,\n        headers: authHeaders\n      });\n      const existing = (searchResp || []).find(t => t.name.toLowerCase() === name.toLowerCase());\n      if (existing) {\n        ids.push(existing.id);\n      } else {\n        const createResp = await httpRequest.call(this, {\n          method: 'POST',\n          url: `${config.baseUrl}/wp-json/wp/v2/tags`,\n          headers: { ...authHeaders, 'Content-Type': 'application/json' },\n          body: { name }\n        });\n        if (createResp?.id) ids.push(createResp.id);\n      }\n    } catch (e) {\n      debug.wp_errors.push({ step: 'CREATE_TAG', name, error: e.message });\n    }\n  }\n  return ids;\n}\n\nasync function getCategories(categoryString) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  let termNames = [];\n  if (categoryString) {\n    termNames = categoryString.split(/[,|]/).map(t => t.trim()).filter(t => t);\n  }\n  if (termNames.length === 0 && config.defaultCategory) {\n    termNames = [config.defaultCategory];\n  }\n  debug.categories_requested = termNames;\n  if (termNames.length === 0) return [];\n  const ids = [];\n  let allCategories = [];\n  try {\n    const catResp = await httpRequest.call(this, {\n      method: 'GET',\n      url: `${config.baseUrl}/wp-json/wp/v2/categories?per_page=100`,\n      headers: authHeaders\n    });\n    allCategories = catResp || [];\n  } catch (e) {\n    debug.wp_errors.push({ step: 'FETCH_CATEGORIES', error: e.message });\n    return [];\n  }\n  for (const name of termNames) {\n    const nameLower = name.toLowerCase();\n    const nameSlug = nameLower.replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n    let found = allCategories.find(c => c.name.toLowerCase() === nameLower);\n    if (!found) found = allCategories.find(c => c.slug === nameSlug);\n    if (!found) found = allCategories.find(c => c.name.toLowerCase().includes(nameLower) || nameLower.includes(c.name.toLowerCase()));\n    if (found) {\n      ids.push(found.id);\n      debug.categories_found.push({ requested: name, matched: found.name, id: found.id });\n    } else {\n      try {\n        const createResp = await httpRequest.call(this, {\n          method: 'POST',\n          url: `${config.baseUrl}/wp-json/n8n/v1/create-category`,\n          headers: { ...authHeaders, 'Content-Type': 'application/json' },\n          body: { name: name, slug: nameSlug }\n        });\n        if (createResp?.id) {\n          ids.push(createResp.id);\n          debug.categories_found.push({ requested: name, created: createResp.created !== false, id: createResp.id });\n        }\n      } catch (createErr) {\n        debug.wp_errors.push({ step: 'CREATE_CATEGORY', requested: name, error: createErr.message });\n      }\n    }\n  }\n  return ids;\n}\n\nasync function updateSeoMeta(postId, contentJson) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  const focusKeyphrase = contentJson.focus_keyphrase || config.topic;\n  \n  try {\n    const seoResp = await httpRequest.call(this, {\n      method: 'POST',\n      url: `${config.baseUrl}/wp-json/n8n/v1/update-seo-meta`,\n      headers: { ...authHeaders, 'Content-Type': 'application/json' },\n      body: {\n        post_id: postId,\n        focus_keyphrase: focusKeyphrase,\n        meta_description: contentJson.meta_description,\n        seo_title: contentJson.title\n      }\n    });\n    debug.seo_meta_updated = seoResp?.updated || true;\n    debug.seo_plugins = seoResp?.seo_plugins || {};\n    return;\n  } catch (e) {\n    debug.seo_meta_updated = `plugin_not_found: ${e.message?.substring(0, 50)}`;\n  }\n  \n  try {\n    await httpRequest.call(this, {\n      method: 'POST',\n      url: `${config.baseUrl}/wp-json/wp/v2/posts/${postId}`,\n      headers: { ...authHeaders, 'Content-Type': 'application/json' },\n      body: {\n        meta: {\n          _yoast_wpseo_focuskw: focusKeyphrase,\n          _yoast_wpseo_metadesc: contentJson.meta_description,\n          rank_math_focus_keyword: focusKeyphrase,\n          rank_math_description: contentJson.meta_description\n        }\n      }\n    });\n    debug.seo_meta_updated = 'rest_api_fallback';\n  } catch (e) {\n    debug.seo_meta_updated = `failed: ${e.message?.substring(0, 50)}`;\n  }\n}\n\nasync function publishPost(postData) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'POST',\n      url: `${config.baseUrl}/wp-json/wp/v2/posts`,\n      headers: { ...authHeaders, 'Content-Type': 'application/json' },\n      body: postData\n    });\n    return resp;\n  } catch (e) {\n    debug.wp_errors.push({ step: 'PUBLISH', error: e.message, statusCode: e.response?.status, response: e.response?.data });\n    throw new Error(`WP POST failed: ${e.message}`);\n  }\n}\n\nasync function pingIndexingService(postUrl) {\n  if (!config.indexingEnabled) {\n    debug.notifications.speedyindex = 'disabled_for_site';\n    return false;\n  }\n  if (config.postStatus !== 'publish') {\n    debug.notifications.speedyindex = 'post_not_published';\n    return false;\n  }\n  \n  // Try SpeedyIndex first\n  if (config.speedyIndexKey) {\n    try {\n      await httpRequest.call(this, {\n        method: 'POST',\n        url: 'https://api.speedyindex.com/v1/index',\n        headers: { 'Authorization': `Bearer ${config.speedyIndexKey}`, 'Content-Type': 'application/json' },\n        body: { url: postUrl }\n      });\n      debug.notifications.speedyindex = 'speedyindex_success';\n      return true;\n    } catch (e) {\n      debug.wp_errors.push({ step: 'SPEEDYINDEX', error: e.message });\n    }\n  }\n  \n  // Fallback to FastIndex.eu\n  if (config.fastIndexKey) {\n    try {\n      const resp = await httpRequest.call(this, {\n        method: 'POST',\n        url: 'https://host060126.eu/api/links',\n        headers: { \n          'Authorization': `Bearer ${config.fastIndexKey}`, \n          'Content-Type': 'application/json' \n        },\n        body: { \n          method: 'gold',\n          links: [postUrl]\n        }\n      });\n      if (resp?.status === 201 || resp?.msg?.includes('success')) {\n        debug.notifications.speedyindex = 'fastindex_success';\n        return true;\n      }\n      debug.wp_errors.push({ step: 'FASTINDEX', error: resp?.message || 'Unknown error' });\n    } catch (e) {\n      debug.wp_errors.push({ step: 'FASTINDEX', error: e.message });\n    }\n  }\n  \n  debug.notifications.speedyindex = 'no_indexing_service';\n  return false;\n}\n\nasync function sendTelegramNotification(message) {\n  if (!config.telegramEnabled) {\n    debug.notifications.telegram = 'disabled_for_site';\n    return false;\n  }\n  if (!config.telegramToken || !config.telegramChatId) {\n    debug.notifications.telegram = 'no_credentials';\n    return false;\n  }\n  try {\n    await httpRequest.call(this, {\n      method: 'POST',\n      url: `https://api.telegram.org/bot${config.telegramToken}/sendMessage`,\n      headers: { 'Content-Type': 'application/json' },\n      body: { chat_id: config.telegramChatId, text: message, parse_mode: 'HTML' }\n    });\n    debug.notifications.telegram = true;\n    return true;\n  } catch (e) {\n    debug.wp_errors.push({ step: 'TELEGRAM', error: e.message });\n    debug.notifications.telegram = `error: ${e.message}`;\n    return false;\n  }\n}\n\nasync function sendEmailNotification(subject, htmlBody) {\n  if (!config.emailEnabled) {\n    debug.notifications.email = 'disabled_for_site';\n    return false;\n  }\n  if (!config.notificationEmail) {\n    debug.notifications.email = 'no_recipient';\n    return false;\n  }\n  if (!config.emailProvider) {\n    debug.notifications.email = 'no_provider';\n    return false;\n  }\n  try {\n    switch (config.emailProvider) {\n      case 'resend':\n        if (!config.resendApiKey) { debug.notifications.email = 'no_resend_key'; return false; }\n        await httpRequest.call(this, {\n          method: 'POST', url: 'https://api.resend.com/emails',\n          headers: { 'Authorization': `Bearer ${config.resendApiKey}`, 'Content-Type': 'application/json' },\n          body: { from: config.emailFrom, to: config.notificationEmail, subject, html: htmlBody }\n        });\n        break;\n      case 'sendgrid':\n        if (!config.sendgridApiKey) { debug.notifications.email = 'no_sendgrid_key'; return false; }\n        await httpRequest.call(this, {\n          method: 'POST', url: 'https://api.sendgrid.com/v3/mail/send',\n          headers: { 'Authorization': `Bearer ${config.sendgridApiKey}`, 'Content-Type': 'application/json' },\n          body: { personalizations: [{ to: [{ email: config.notificationEmail }] }], from: { email: config.emailFrom }, subject, content: [{ type: 'text/html', value: htmlBody }] }\n        });\n        break;\n      case 'mailgun':\n        if (!config.mailgunApiKey || !config.mailgunDomain) { debug.notifications.email = 'no_mailgun_config'; return false; }\n        const formData = new URLSearchParams();\n        formData.append('from', config.emailFrom);\n        formData.append('to', config.notificationEmail);\n        formData.append('subject', subject);\n        formData.append('html', htmlBody);\n        await httpRequest.call(this, {\n          method: 'POST', url: `https://api.mailgun.net/v3/${config.mailgunDomain}/messages`,\n          headers: { 'Authorization': `Basic ${Buffer.from(`api:${config.mailgunApiKey}`).toString('base64')}`, 'Content-Type': 'application/x-www-form-urlencoded' },\n          body: formData.toString()\n        });\n        break;\n      case 'smtp2go':\n        if (!config.smtp2goApiKey) { debug.notifications.email = 'no_smtp2go_key'; return false; }\n        await httpRequest.call(this, {\n          method: 'POST', url: 'https://api.smtp2go.com/v3/email/send',\n          headers: { 'Content-Type': 'application/json' },\n          body: { api_key: config.smtp2goApiKey, sender: config.emailFrom, to: [config.notificationEmail], subject, html_body: htmlBody }\n        });\n        break;\n      default:\n        debug.notifications.email = `unknown_provider: ${config.emailProvider}`;\n        return false;\n    }\n    debug.notifications.email = true;\n    return true;\n  } catch (e) {\n    debug.wp_errors.push({ step: 'EMAIL', provider: config.emailProvider, error: e.message });\n    debug.notifications.email = `error: ${e.message}`;\n    return false;\n  }\n}\n\ntry {\n  currentStep = 'WP_AUTH_CHECK';\n  executionLog.push({ step: currentStep, status: 'started', time: new Date().toISOString() });\n  const authCheck = await wpAuthSanityCheck.call(this);\n  executionLog.push({ step: currentStep, status: 'completed', user: authCheck.user });\n  \n  currentStep = 'FETCH_HINTS';\n  executionLog.push({ step: currentStep, status: 'started' });\n  const [serpResults, youtubeCandidates] = await Promise.all([fetchSerpHints.call(this), fetchYouTubeCandidates.call(this)]);\n  executionLog.push({ step: currentStep, status: 'completed', serp: serpResults.length, youtube: youtubeCandidates.length });\n  \n  currentStep = 'GENERATE_CONTENT';\n  executionLog.push({ step: currentStep, status: 'started' });\n  const contentJson = await generateContentJson.call(this);\n  const validationErrors = validateContent(contentJson);\n  if (validationErrors.length > 0) throw new Error(`Content validation failed: ${validationErrors.join(', ')}`);\n  executionLog.push({ step: currentStep, status: 'completed', title: contentJson.title?.substring(0, 50) });\n  \n  currentStep = 'PROCESS_IMAGES';\n  let processedHtml = contentJson.content_html;\n  let featuredImageId = null;\n  if (config.imagesCount > 0) {\n    executionLog.push({ step: currentStep, status: 'started', count: config.imagesCount });\n    const titleSlug = contentJson.slug || contentJson.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').substring(0, 50);\n    const imgResult = await processImagePlaceholders.call(this, processedHtml, titleSlug);\n    processedHtml = imgResult.html;\n    featuredImageId = imgResult.featuredImageId;\n    executionLog.push({ step: currentStep, status: 'completed', uploaded: debug.images_uploaded, featuredId: featuredImageId });\n  } else {\n    executionLog.push({ step: currentStep, status: 'skipped', reason: 'images_count=0' });\n  }\n  \n  currentStep = 'INTERNAL_LINKS';\n  if (config.internalLinksCount > 0) {\n    executionLog.push({ step: currentStep, status: 'started' });\n    processedHtml = await injectInternalLinks.call(this, processedHtml, contentJson.internal_anchor_phrases);\n    executionLog.push({ step: currentStep, status: 'completed', inserted: debug.internal_links_inserted });\n  } else {\n    executionLog.push({ step: currentStep, status: 'skipped' });\n  }\n  \n  currentStep = 'EXTERNAL_LINKS';\n  if (config.externalLinksCount > 0 && serpResults.length > 0) {\n    executionLog.push({ step: currentStep, status: 'started' });\n    processedHtml = injectExternalLinks(processedHtml, contentJson.external_anchor_phrases, serpResults);\n    executionLog.push({ step: currentStep, status: 'completed', inserted: debug.external_links_inserted });\n  } else {\n    executionLog.push({ step: currentStep, status: 'skipped', reason: serpResults.length === 0 ? 'no SERP results' : 'disabled' });\n  }\n  \n  currentStep = 'YOUTUBE_EMBEDS';\n  if (config.youtubeCount > 0 && config.youtubeKey) {\n    executionLog.push({ step: currentStep, status: 'started' });\n    processedHtml = await injectYouTubeEmbeds.call(this, processedHtml, contentJson.youtube_anchor_phrases, youtubeCandidates);\n    executionLog.push({ step: currentStep, status: 'completed', inserted: debug.youtube_embeds_inserted });\n  } else {\n    executionLog.push({ step: currentStep, status: 'skipped' });\n  }\n  \n  currentStep = 'TERMS';\n  const [tagIds, categoryIds] = await Promise.all([getOrCreateTags.call(this, config.tags, contentJson.tag_suggestions), getCategories.call(this, config.categories)]);\n  executionLog.push({ step: currentStep, status: 'completed', tags: tagIds.length, categories: categoryIds.length, categoryDetails: debug.categories_found });\n  \n  currentStep = 'PUBLISH_POST';\n  executionLog.push({ step: currentStep, status: 'started' });\n  \n  const postData = {\n    title: contentJson.title,\n    slug: contentJson.slug,\n    content: processedHtml,\n    excerpt: contentJson.meta_description,\n    status: config.postStatus,\n    comment_status: 'open',\n    ping_status: 'open'\n  };\n  if (featuredImageId) postData.featured_media = featuredImageId;\n  if (tagIds.length > 0) postData.tags = tagIds;\n  if (categoryIds.length > 0) postData.categories = categoryIds;\n  const postResp = await publishPost.call(this, postData);\n  if (!postResp?.id) throw new Error('Failed to create WordPress post - no ID returned');\n  executionLog.push({ step: currentStep, status: 'completed', postId: postResp.id });\n  \n  currentStep = 'POST_PROCESSING';\n  \n  await updateSeoMeta.call(this, postResp.id, contentJson);\n  await pingIndexingService.call(this, postResp.link);\n  \n  const indexStatus = debug.notifications.speedyindex === 'speedyindex_success' ? '✅ SpeedyIndex' : \n                       debug.notifications.speedyindex === 'fastindex_success' ? '✅ FastIndex' : \n                       debug.notifications.speedyindex === 'disabled_for_site' ? '⏸️ Disabled' :\n                       debug.notifications.speedyindex === 'post_not_published' ? '⏸️ Draft' :\n                       '❌ Failed';\n  const notifyMessage = `✅ <b>New Post Published</b>\\n\\n📝 ${contentJson.title}\\n🌐 ${site.site_name || config.baseUrl}\\n🔗 ${postResp.link || 'Draft'}\\n📊 Images: ${debug.images_uploaded}/${debug.images_requested}\\n🔗 Internal: ${debug.internal_links_inserted}/${debug.internal_links_requested}\\n🌐 External: ${debug.external_links_inserted}/${debug.external_links_requested}\\n📺 YouTube: ${debug.youtube_embeds_inserted}/${debug.youtube_embeds_requested}\\n🏷️ Categories: ${categoryIds.length}\\n🔍 Indexing: ${indexStatus}`;\n  await sendTelegramNotification.call(this, notifyMessage);\n  \n  const emailHtml = `<h2>✅ New Post Published</h2><p><strong>Site:</strong> ${site.site_name || config.baseUrl}</p><p><strong>Title:</strong> ${contentJson.title}</p><p><strong>URL:</strong> <a href=\"${postResp.link}\">${postResp.link || 'Draft'}</a></p><p><strong>Images:</strong> ${debug.images_uploaded}/${debug.images_requested}</p><p><strong>Internal Links:</strong> ${debug.internal_links_inserted}/${debug.internal_links_requested}</p><p><strong>External Links:</strong> ${debug.external_links_inserted}/${debug.external_links_requested}</p><p><strong>YouTube:</strong> ${debug.youtube_embeds_inserted}/${debug.youtube_embeds_requested}</p><p><strong>Categories:</strong> ${categoryIds.length}</p>`;\n  await sendEmailNotification.call(this, `New Post: ${contentJson.title}`, emailHtml);\n  \n  executionLog.push({ step: currentStep, status: 'completed', notifications: debug.notifications });\n  \n  return [{ json: { ok: true, post_id: postResp.id, post_url: postResp.link, title: contentJson.title, slug: contentJson.slug, focus_keyphrase: contentJson.focus_keyphrase, status: postResp.status, featured_image_id: featuredImageId, debug, execution_log: executionLog, site, topicRow } }];\n} catch (error) {\n  executionLog.push({ step: currentStep, status: 'FAILED', error: error.message });\n  \n  const failMsg = `❌ <b>Post Failed</b>\\n\\n📝 ${config.topic}\\n🌐 ${site.site_name || config.baseUrl}\\n🚫 Step: ${currentStep}\\n⚠️ ${error.message}`;\n  await sendTelegramNotification.call(this, failMsg).catch(() => {});\n  \n  const failEmailHtml = `<h2>❌ Post Failed</h2><p><strong>Site:</strong> ${site.site_name || config.baseUrl}</p><p><strong>Topic:</strong> ${config.topic}</p><p><strong>Step:</strong> ${currentStep}</p><p><strong>Error:</strong> ${error.message}</p>`;\n  await sendEmailNotification.call(this, `FAILED: ${config.topic}`, failEmailHtml).catch(() => {});\n  \n  return [{ json: { ok: false, error: error.message, failed_at_step: currentStep, debug, execution_log: executionLog, stack: error.stack, site, topicRow } }];\n}\n"
      },
      "id": "engine-001",
      "name": "Publisher Engine (Code)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        220,
        0
      ]
    }
  ],
  "connections": {
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Publisher Engine (Code)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "v3.0-no-globals",
  "meta": {
    "templateId": "autoblogger-publisher-v3"
  },
  "tags": []
}
