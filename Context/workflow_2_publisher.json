{
  "name": "Publisher (Autoblogging Engine)",
  "nodes": [
    {
      "parameters": {},
      "id": "f8a3b218-5d44-4624-b1a4-884d778dc61a",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [
        0,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "/**\n * Publisher (Autoblogging Engine) \u2014 single Code node version.\n * n8n v2.3.5 compatible (uses this.helpers.httpRequest).\n *\n * INPUT: { site: {...}, topicRow: {...} }\n * OUTPUT: { ok: boolean, post_url?: string, post_id?: number, error?: string }\n */\n\nfunction pick(arr, n) {\n  const a = [...(arr || [])];\n  for (let i = a.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [a[i], a[j]] = [a[j], a[i]];\n  }\n  return a.slice(0, Math.max(0, n));\n}\n\nfunction splitCsv(v) {\n  if (!v || typeof v !== 'string') return [];\n  return v.split(',').map(s => s.trim()).filter(Boolean);\n}\n\nfunction isNumericStr(s) {\n  return typeof s === 'string' && /^[0-9]+$/.test(s.trim());\n}\n\nfunction domainFromBaseUrl(baseUrl) {\n  try {\n    const u = new URL(baseUrl);\n    return u.hostname.replace(/^www\\./, '');\n  } catch {\n    return 'example.com';\n  }\n}\n\nfunction extractImagePlaceholders(html) {\n  const re = /<!--\\s*WPIMG\\s+alt=\"([^\"]+)\"\\s*-->/g;\n  const alts = [];\n  let m;\n  while ((m = re.exec(html)) !== null) alts.push(m[1]);\n  return alts;\n}\n\nfunction replaceNthPlaceholder(html, alt, replacement) {\n  const needle = `<!-- WPIMG alt=\"${alt}\" -->`;\n  const idx = html.indexOf(needle);\n  if (idx === -1) return html;\n  return html.slice(0, idx) + replacement + html.slice(idx + needle.length);\n}\n\nfunction slugify(s) {\n  return String(s || '')\n    .toLowerCase()\n    .replace(/&/g, ' and ')\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '')\n    .slice(0, 80);\n}\n\nfunction injectLinksByParagraph(html, links, maxPerParagraph = 1) {\n  // Split by </p> while keeping it.\n  const parts = html.split(/<\\/p>/i);\n  const used = new Set();\n  const out = parts.map((p, idx) => ({ idx, p }));\n  let injected = 0;\n\n  for (const l of links) {\n    const candidates = out\n      .map((o, i) => ({ i, text: o.p }))\n      .filter(o => o.text && o.text.includes(l.phrase))\n      .filter(o => !/<a\\s/i.test(o.text))\n      .filter(o => !used.has(o.i));\n\n    if (!candidates.length) continue;\n    // Random candidate, then replace first occurrence\n    const chosen = candidates[Math.floor(Math.random() * candidates.length)];\n    out[chosen.i].p = out[chosen.i].p.replace(l.phrase, l.replacement);\n    used.add(chosen.i);\n    injected++;\n    if (injected >= links.length) break;\n  }\n\n  // Re-join </p> that we removed in split\n  return out.map(o => o.p).join('</p>');\n}\n\nfunction injectEmbedsSpaced(html, embeds, minGap = 2) {\n  const parts = html.split(/<\\/p>/i);\n  const usedIdx = [];\n  const out = parts.map((p, idx) => ({ idx, p }));\n\n  for (const e of embeds) {\n    const candidates = out\n      .map(o => o.idx)\n      .filter(i => out[i].p && out[i].p.includes(e.phrase))\n      .filter(i => {\n        if (!usedIdx.length) return true;\n        return usedIdx.every(u => Math.abs(u - i) >= minGap);\n      });\n\n    if (!candidates.length) continue;\n    const i = candidates[Math.floor(Math.random() * candidates.length)];\n    // Insert embed after the paragraph that contains phrase (WordPress will oEmbed from the plain URL wrapper)\n    out[i].p = out[i].p.replace(e.phrase, e.phrase) + `</p>${e.embedHtml}<p>`;\n    usedIdx.push(i);\n  }\n\n  return out.map(o => o.p).join('</p>');\n}\n\nasync function httpJson(ctx, opts) {\n  return await ctx.helpers.httpRequest({\n    json: true,\n    ...opts,\n  });\n}\n\nasync function httpBuffer(ctx, opts) {\n  // Returns Buffer\n  const res = await ctx.helpers.httpRequest({\n    json: false,\n    encoding: null,\n    ...opts,\n  });\n  return Buffer.isBuffer(res) ? res : Buffer.from(res);\n}\n\nasync function wpJson(ctx, baseUrl, authHeader, opts) {\n  return await httpJson(ctx, {\n    ...opts,\n    url: `${baseUrl.replace(/\\/$/, '')}${opts.url.startsWith('/') ? '' : '/'}${opts.url}`,\n    headers: {\n      ...(opts.headers || {}),\n      Authorization: authHeader,\n    }\n  });\n}\n\nfunction buildBasicAuth(user, pass) {\n  const token = Buffer.from(`${user}:${pass}`).toString('base64');\n  return `Basic ${token}`;\n}\n\nasync function run() {\n  const input = $json || {};\n  const site = input.site || input.site_config || {};\n  const topicRow = input.topicRow || input.topic_row || input.topic || {};\n\n  const topic = topicRow.topic || input.topic || '';\n  if (!topic) return { ok: false, error: 'Missing topic', site, topicRow };\n\n  const baseUrl = site.base_url;\n  const wpUser = site.wp_user;\n  const wpPass = site.wp_app_password;\n\n  if (!baseUrl || !wpUser || !wpPass) {\n    return { ok: false, error: 'Missing WordPress config (base_url/wp_user/wp_app_password)', site, topicRow };\n  }\n\n  const domain = domainFromBaseUrl(baseUrl);\n  const authHeader = buildBasicAuth(wpUser, wpPass);\n\n  const counts = {\n    images: Number(site.images_count || 0),\n    internal: Number(site.internal_links_count || 0),\n    external: Number(site.external_links_count || 0),\n    youtube: Number(site.youtube_embeds_count || 0),\n  };\n\n  // --- A) SERP hints (Google CSE) ---\n  const cseKey = site.google_cse_api_key || $env.GOOGLE_CSE_API_KEY || '{GOOGLE_CSE_API_KEY}';\n  const cseCx  = site.google_cse_cx || $env.GOOGLE_CSE_CX || '{GOOGLE_CSE_CX}';\n\n  let serp = [];\n  if (cseKey && cseCx) {\n    const cseUrl = `https://www.googleapis.com/customsearch/v1?q=${encodeURIComponent(topic)}&key=${encodeURIComponent(cseKey)}&cx=${encodeURIComponent(cseCx)}&num=10`;\n    try {\n      const cse = await httpJson(this, { method: 'GET', url: cseUrl });\n      serp = (cse.items || []).map(it => ({\n        title: it.title,\n        snippet: it.snippet,\n        url: it.link\n      }));\n    } catch (e) {\n      // Don't hard fail on SERP\n      serp = [];\n    }\n  }\n\n  // --- B) YouTube candidates ---\n  const youtubeKey = site.youtube_api_key || $env.YOUTUBE_API_KEY || '{YOUTUBE_API_KEY}';\n\n  let youtubeCandidates = [];\n  if (counts.youtube > 0 && youtubeKey) {\n    const ytUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=5&q=${encodeURIComponent(topic)}&key=${encodeURIComponent(youtubeKey)}`;\n    try {\n      const yt = await httpJson(this, { method: 'GET', url: ytUrl });\n      youtubeCandidates = (yt.items || [])\n        .map(x => x.id && x.id.videoId ? `https://www.youtube.com/watch?v=${x.id.videoId}` : null)\n        .filter(Boolean);\n    } catch {\n      youtubeCandidates = [];\n    }\n  }\n\n  // --- C) OpenAI content generation (STRICT JSON) ---\n  const openaiKey = $env.OPENAI_API_KEY || site.openai_api_key || '{OPENAI_API_KEY}';\n  const openaiModel = site.openai_model || $env.OPENAI_MODEL_DEFAULT || '{OPENAI_MODEL}';\n\n  const prompt = {\n    role: 'user',\n    content: [\n      `Topic: ${topic}`,\n      ``,\n      `Site tone: ${site.tone || 'helpful, human, practical'}`,\n      `Word count range: ${site.min_words || 900}..${site.max_words || 1600}`,\n      `FAQ count: ${site.faq_count || 6}`,\n      `tables_mode: ${site.tables_mode || 'auto'}`,\n      `charts_mode: ${site.charts_mode || 'auto'}`,\n      ``,\n      `Counts (0 disables): images=${counts.images}, internal_links=${counts.internal}, external_links=${counts.external}, youtube_embeds=${counts.youtube}`,\n      ``,\n      `SERP results (for hints + external link pool): ${JSON.stringify(serp)}`,\n      `YouTube candidates (only if embeds enabled): ${JSON.stringify(youtubeCandidates)}`,\n      ``,\n      `HARD RULES:`,\n      `- Return ONLY valid JSON. No markdown fences. No extra keys beyond the contract.`,\n      `- No RankMath meta updates. No fact checking. No citations / no \"Sources\" section.`,\n      `- Links/images/youtube MUST be contextual and NOT form a visible placement pattern.`,\n      `- Tables only if useful; charts only if necessary (not always).`,\n      `- If images_count>0, include EXACTLY images_count placeholders in content_html like: <!-- WPIMG alt=\"DESCRIPTIVE ALT TEXT\" -->`,\n      `  * ALT texts must be unique and descriptive.`,\n      ``,\n      `JSON CONTRACT (exact keys):`,\n      `{`,\n      `  \"title\": \"string\",`,\n      `  \"slug\": \"string\",`,\n      `  \"meta_description\": \"string\",`,\n      `  \"tag_suggestions\": [\"optional\",\"array\"],`,\n      `  \"content_html\": \"string (HTML with H2/H3)\",`,\n      `  \"internal_anchor_phrases\": [\"array of phrases that appear verbatim in content_html\"],`,\n      `  \"external_anchor_phrases\": [\"array of phrases that appear verbatim in content_html\"],`,\n      `  \"youtube_anchor_phrases\": [\"array of phrases that appear verbatim in content_html\"]`,\n      `}`,\n    ].join('\\n')\n  };\n\n  let draft;\n  try {\n    const chat = await httpJson(this, {\n      method: 'POST',\n      url: 'https://api.openai.com/v1/chat/completions',\n      headers: { Authorization: `Bearer ${openaiKey}` },\n      body: {\n        model: openaiModel,\n        temperature: 0.8,\n        response_format: { type: \"json_object\" },\n        messages: [\n          {\n            role: 'system',\n            content: 'You write SEO-friendly WordPress blog posts. You must output ONLY strict JSON that matches the provided contract.'\n          },\n          prompt\n        ]\n      }\n    });\n\n    const content = chat.choices?.[0]?.message?.content;\n    draft = JSON.parse(content);\n  } catch (e) {\n    return { ok: false, error: `OpenAI generation failed: ${e.message || String(e)}` };\n  }\n\n  // Basic validation\n  if (!draft?.title || !draft?.slug || !draft?.meta_description || !draft?.content_html) {\n    return { ok: false, error: 'OpenAI returned invalid JSON (missing required keys)' };\n  }\n\n  let html = String(draft.content_html);\n\n  // --- Image placeholder validation ---\n  const alts = extractImagePlaceholders(html);\n  if (counts.images > 0) {\n    if (alts.length !== counts.images) {\n      return { ok: false, error: `Expected ${counts.images} image placeholders; found ${alts.length}` };\n    }\n  }\n\n  // --- D) Images pipeline ---\n  let featuredMediaId = null;\n\n  if (counts.images > 0) {\n    for (let i = 0; i < alts.length; i++) {\n      const alt = alts[i];\n      const providerPriority = String(site.image_provider_priority || $env.IMAGE_PROVIDER_PRIORITY_DEFAULT || 'openai,fal,pexels')\n        .split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);\n      // Back-compat: if image_source is set and not already first, move it to front\n      const primary = (site.image_source || 'openai').toLowerCase();\n      if (primary && !providerPriority.includes(primary)) providerPriority.unshift(primary);\n      else if (primary && providerPriority[0] !== primary) {\n        const rest = providerPriority.filter(p=>p!==primary);\n        providerPriority.splice(0, providerPriority.length, primary, ...rest);\n      }\n\n      const openaiImageModel = site.openai_image_model || $env.OPENAI_IMAGE_MODEL_DEFAULT || 'gpt-image-1-mini';\n      const falKey = site.fal_api_key || $env.FAL_API_KEY || '{FAL_API_KEY}';\n      const pexelsKey = site.pexels_api_key || $env.PEXELS_API_KEY || '{PEXELS_API_KEY}';\n\n      async function tryOpenAI() {\n        const img = await httpJson(this, {\n          method: 'POST',\n          url: 'https://api.openai.com/v1/images/generations',\n          headers: { Authorization: `Bearer ${openaiKey}` },\n          body: { model: openaiImageModel, prompt: alt, size: '1024x1024' }\n        });\n        const b64 = img.data?.[0]?.b64_json;\n        if (!b64) throw new Error('OpenAI image API returned no b64_json');\n        return { buf: Buffer.from(b64, 'base64'), filename: `wpimg-${i+1}.png`, contentType: 'image/png' };\n      }\n\n      async function tryFal() {\n        if (!falKey) throw new Error('Missing fal_api_key');\n        const endpoint = site.fal_image_endpoint || $env.FAL_IMAGE_ENDPOINT || 'https://queue.fal.run/fal-ai/flux/dev';\n        // Generic fal queue API: submit then poll status_url\n        const submitted = await httpJson(this, {\n          method: 'POST',\n          url: endpoint,\n          headers: { Authorization: `Key ${falKey}` },\n          body: { prompt: alt }\n        });\n        const statusUrl = submitted?.status_url || submitted?.urls?.get || submitted?.url;\n        if (!statusUrl) throw new Error('fal response missing status_url');\n        let final = null;\n        for (let t=0; t<20; t++) {\n          const st = await httpJson(this, { method: 'GET', url: statusUrl, headers: { Authorization: `Key ${falKey}` } });\n          if (st?.status === 'COMPLETED' || st?.status === 'completed' || st?.done) {\n            final = st; break;\n          }\n          if (st?.status === 'FAILED' || st?.status === 'failed') throw new Error('fal generation failed');\n          await new Promise(r => setTimeout(r, 1500));\n        }\n        const imageUrl = final?.response?.images?.[0]?.url || final?.images?.[0]?.url || final?.output?.[0];\n        if (!imageUrl) throw new Error('fal completed but no image url');\n        const buf = await httpBuffer(this, { method: 'GET', url: imageUrl });\n        return { buf, filename: `wpimg-${i+1}.jpg`, contentType: 'image/jpeg' };\n      }\n\n      async function tryPexels() {\n        if (!pexelsKey) throw new Error('Missing pexels_api_key');\n        const p = await httpJson(this, {\n          method: 'GET',\n          url: `https://api.pexels.com/v1/search?query=${encodeURIComponent(alt)}&per_page=1&orientation=landscape`,\n          headers: { Authorization: pexelsKey }\n        });\n        const photo = p.photos?.[0];\n        const imgUrl = photo?.src?.large || photo?.src?.original;\n        if (!imgUrl) throw new Error(`Pexels returned no image for alt: ${alt}`);\n        const buf = await httpBuffer(this, { method: 'GET', url: imgUrl });\n        return { buf, filename: `wpimg-${i+1}.jpg`, contentType: 'image/jpeg' };\n      }\n\n      async function getImage() {\n        let lastErr = null;\n        for (const prov of providerPriority) {\n          try {\n            if (prov === 'openai') return await tryOpenAI.call(this);\n            if (prov === 'fal' || prov === 'fal.ai' || prov === 'falai') return await tryFal.call(this);\n            if (prov === 'pexels') return await tryPexels.call(this);\n          } catch (e) {\n            lastErr = e;\n          }\n        }\n        throw lastErr || new Error('No image providers available');\n      }\n\n      let buf, filename, contentType;\n      const imgResult = await getImage.call(this);\n      buf = imgResult.buf;\n      filename = imgResult.filename;\n      contentType = imgResult.contentType;\n\n      // Upload to WordPress media\n      let media;\n      try {\n        media = await wpJson(this, baseUrl, authHeader, {\n          method: 'POST',\n          url: '/wp-json/wp/v2/media',\n          headers: {},\n          formData: {\n            file: {\n              value: buf,\n              options: { filename, contentType }\n            }\n          }\n        });\n      } catch (e) {\n        return { ok: false, error: `WP media upload failed: ${e.message || String(e)}` };\n      }\n\n      const mediaId = media.id;\n      const mediaUrl = media.source_url || media.guid?.rendered;\n      if (!mediaId || !mediaUrl) {\n        return { ok: false, error: 'WP media upload returned missing id/url' };\n      }\n\n      // Update media alt text: ORIGINAL_ALT + \" | \" + domain\n      const altFinal = `${alt} | ${domain}`;\n      try {\n        await wpJson(this, baseUrl, authHeader, {\n          method: 'POST',\n          url: `/wp-json/wp/v2/media/${mediaId}`,\n          body: { alt_text: altFinal }\n        });\n      } catch {\n        // Non-fatal\n      }\n\n      // Replace placeholder with <figure><img ...></figure>\n      const fig = `<figure><img src=\"${mediaUrl}\" alt=\"${altFinal}\" loading=\"lazy\"></figure>`;\n      html = replaceNthPlaceholder(html, alt, fig);\n\n      if (i === 0) featuredMediaId = mediaId;\n    }\n  }\n\n  // --- E) Internal links injection ---\n  if (counts.internal > 0 && Array.isArray(draft.internal_anchor_phrases)) {\n    const phrases = pick(draft.internal_anchor_phrases, counts.internal);\n\n    const links = [];\n    for (const phrase of phrases) {\n      try {\n        const posts = await wpJson(this, baseUrl, authHeader, {\n          method: 'GET',\n          url: `/wp-json/wp/v2/posts?search=${encodeURIComponent(phrase)}&per_page=5&status=publish`\n        });\n        const first = Array.isArray(posts) ? posts[0] : null;\n        if (first?.link) {\n          links.push({\n            phrase,\n            replacement: `<a href=\"${first.link}\">${phrase}</a>`\n          });\n        }\n      } catch {\n        // skip\n      }\n    }\n    if (links.length) html = injectLinksByParagraph(html, links, 1);\n  }\n\n  // --- F) External links injection ---\n  if (counts.external > 0 && Array.isArray(draft.external_anchor_phrases) && serp.length) {\n    const phrases = pick(draft.external_anchor_phrases, counts.external);\n    const links = [];\n\n    for (const phrase of phrases) {\n      const chosen = serp[Math.floor(Math.random() * serp.length)];\n      if (!chosen?.url) continue;\n      links.push({\n        phrase,\n        replacement: `<a href=\"${chosen.url}\" target=\"_blank\" rel=\"nofollow noopener\">${phrase}</a>`\n      });\n    }\n\n    if (links.length) html = injectLinksByParagraph(html, links, 1);\n  }\n\n  // --- G) YouTube embed injection ---\n  if (counts.youtube > 0 && Array.isArray(draft.youtube_anchor_phrases) && youtubeCandidates.length) {\n    const phrases = pick(draft.youtube_anchor_phrases, counts.youtube);\n    const embeds = phrases.map((phrase, idx) => {\n      const url = youtubeCandidates[idx % youtubeCandidates.length];\n      // WP oEmbed works best when the plain URL is in the wrapper\n      const embedHtml = `<figure class=\"wp-block-embed is-type-video is-provider-youtube\"><div class=\"wp-block-embed__wrapper\">${url}</div></figure>`;\n      return { phrase, embedHtml };\n    });\n\n    html = injectEmbedsSpaced(html, embeds, 2);\n  }\n\n  // --- H) Tags + Categories (optional; skip if absent) ---\n  // Tags: user tags > OpenAI suggestions > none\n  const userTags = splitCsv(topicRow.tags);\n  const aiTags = Array.isArray(draft.tag_suggestions) ? draft.tag_suggestions : [];\n  const tagsToUse = userTags.length ? userTags : (aiTags.length ? aiTags : []);\n\n  const tagIds = [];\n  for (const tag of tagsToUse) {\n    try {\n      const existing = await wpJson(this, baseUrl, authHeader, {\n        method: 'GET',\n        url: `/wp-json/wp/v2/tags?search=${encodeURIComponent(tag)}&per_page=10`\n      });\n      const found = Array.isArray(existing) ? existing.find(t => String(t.name).toLowerCase() === String(tag).toLowerCase()) : null;\n      if (found?.id) {\n        tagIds.push(found.id);\n      } else {\n        const created = await wpJson(this, baseUrl, authHeader, {\n          method: 'POST',\n          url: `/wp-json/wp/v2/tags`,\n          body: { name: tag }\n        });\n        if (created?.id) tagIds.push(created.id);\n      }\n    } catch {\n      // skip\n    }\n  }\n\n  const categoriesToUse = splitCsv(topicRow.categories);\n  const categoryIds = [];\n  for (const cat of categoriesToUse) {\n    if (isNumericStr(cat)) {\n      categoryIds.push(Number(cat.trim()));\n      continue;\n    }\n    try {\n      const existing = await wpJson(this, baseUrl, authHeader, {\n        method: 'GET',\n        url: `/wp-json/wp/v2/categories?search=${encodeURIComponent(cat)}&per_page=10`\n      });\n      const found = Array.isArray(existing) ? existing.find(c => String(c.name).toLowerCase() === String(cat).toLowerCase()) : null;\n      if (found?.id) {\n        categoryIds.push(found.id);\n      } else {\n        const created = await wpJson(this, baseUrl, authHeader, {\n          method: 'POST',\n          url: `/wp-json/wp/v2/categories`,\n          body: { name: cat }\n        });\n        if (created?.id) categoryIds.push(created.id);\n      }\n    } catch {\n      // skip\n    }\n  }\n\n  // --- I) Publish post ---\n  const status = (site.post_status || 'draft').toLowerCase();\n  const postBody = {\n    title: draft.title,\n    slug: draft.slug || slugify(draft.title),\n    status: (status === 'publish' ? 'publish' : 'draft'),\n    content: html,\n    excerpt: draft.meta_description,\n  };\n  if (featuredMediaId) postBody.featured_media = featuredMediaId;\n  if (tagIds.length) postBody.tags = tagIds;\n  if (categoryIds.length) postBody.categories = categoryIds;\n\n  let createdPost;\n  try {\n    createdPost = await wpJson(this, baseUrl, authHeader, {\n      method: 'POST',\n      url: `/wp-json/wp/v2/posts`,\n      body: postBody\n    });\n  } catch (e) {\n    return { ok: false, error: `WP post creation failed: ${e.message || String(e)}` };\n  }\n\n  const postUrl = createdPost?.link;\n  if (!postUrl) return { ok: false, error: 'WP post created but no URL returned' };\n\n  // --- J) SpeedyIndex (optional) ---\n  const speedyKey = site.speedyindex_api_key || $env.SPEEDYINDEX_API_KEY || '{SPEEDYINDEX_API_KEY}';\n\n  if (speedyKey) {\n    try {\n      await httpJson(this, {\n        method: 'POST',\n        url: '{SPEEDYINDEX_ENDPOINT_URL}',\n        headers: { 'X-API-KEY': speedyKey },\n        body: { url: postUrl }\n      });\n    } catch {\n      // non-fatal\n    }\n  }\n\n  return { ok: true, post_url: postUrl, post_id: createdPost?.id, site, topicRow };\n}\n\nreturn run().then(r => [{ json: r }]).catch(e => [{ json: { ok: false, error: e.message || String(e), site: ($json.site || $json.site_config || null), topicRow: ($json.topicRow || $json.topic_row || null) } }]);\n"
      },
      "id": "d64b17ce-9c12-419b-83af-4344c6969ce1",
      "name": "Publisher Engine (Code)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        280,
        0
      ]
    }
  ],
  "connections": {
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Publisher Engine (Code)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "6baeb9e4-4ed5-41d0-8604-cdac376c037c",
  "id": "1a4362f0-7830-40df-855e-21dcc598a9f7",
  "tags": []
}