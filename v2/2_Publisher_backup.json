{
  "name": "2. Publisher (Autoblogger Engine)",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "id": "trigger-pub-001",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [0, 0]
    },
    {
      "parameters": {
        "jsCode": "/**\n * Inject Globals - Merge incoming data with n8n variables\n * Makes all required API keys and config available to the main engine\n */\nconst vars = {\n  OPENAI_API_KEY: $vars.OPENAI_API_KEY || '',\n  OPENAI_MODEL: $vars.OPENAI_MODEL || 'gpt-4o-mini',\n  OPENAI_IMAGE_MODEL: $vars.OPENAI_IMAGE_MODEL || 'dall-e-3',\n  GOOGLE_CSE_API_KEY: $vars.GOOGLE_CSE_API_KEY || '',\n  GOOGLE_CSE_CX: $vars.GOOGLE_CSE_CX || '',\n  YOUTUBE_API_KEY: $vars.YOUTUBE_API_KEY || '',\n  FAL_API_KEY: $vars.FAL_API_KEY || '',\n  PEXELS_API_KEY: $vars.PEXELS_API_KEY || '',\n  TELEGRAM_BOT_TOKEN: $vars.TELEGRAM_BOT_TOKEN || '',\n  TELEGRAM_CHAT_ID: $vars.TELEGRAM_CHAT_ID || ''\n};\n\nreturn [{\n  json: {\n    globals: vars,\n    ...($json || {})\n  }\n}];\n"
      },
      "id": "inject-globals-001",
      "name": "Inject Globals",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 0]
    },
    {
      "parameters": {
        "jsCode": "/**\n * ========================================================\n * AUTOBLOGGER PUBLISHER ENGINE v2.1 (Hardened Edition)\n * ========================================================\n * \n * This is a complete, standalone autoblogging engine that:\n * 1. Generates SEO-optimized blog content with OpenAI\n * 2. Creates or fetches images (OpenAI DALL-E, fal.ai, Pexels)\n * 3. Fetches external links via Google Custom Search\n * 4. Embeds YouTube videos\n * 5. Publishes to WordPress via JWT or Basic Auth\n * \n * Expected Input:\n * - site_config: { base_url, wp_user, wp_app_password, auth_mode, jwt_user, jwt_password, jwt_token, ... }\n * - topicRow: { topic, tags, categories, ... }\n * - globals: { OPENAI_API_KEY, GOOGLE_CSE_API_KEY, ... }\n */\n\n// ============================================================\n// 1. INPUT PARSING (Robust - handles multiple input shapes)\n// ============================================================\nfunction parseInput(json) {\n  // Handle various input structures\n  let site = json.site_config || json.site || json.siteConfig || {};\n  let topicRow = json.topicRow || json.topic_row || json.row || {};\n  let globals = json.globals || {};\n  \n  // If site is nested differently\n  if (!site.base_url && json.base_url) {\n    site = json;\n  }\n  \n  // Extract topic string\n  let topic = topicRow.topic || topicRow.keyword || json.topic || json.keyword || '';\n  \n  return { site, topicRow, globals, topic };\n}\n\nconst input = $input.first().json;\nconst { site, topicRow, globals, topic } = parseInput(input);\n\nif (!topic) {\n  return [{ json: { ok: false, error: 'Missing topic', debug: { input } } }];\n}\n\nif (!site.base_url) {\n  return [{ json: { ok: false, error: 'Missing site base_url', debug: { site, input } } }];\n}\n\n// ============================================================\n// 2. CONFIGURATION\n// ============================================================\nconst config = {\n  // Site\n  baseUrl: site.base_url.replace(/\\/$/, ''),\n  authMode: (site.auth_mode || 'jwt').toLowerCase(),\n  wpUser: site.wp_user || site.jwt_user || '',\n  wpPassword: site.wp_app_password || '',\n  jwtUser: site.jwt_user || '',\n  jwtPassword: site.jwt_password || '',\n  jwtToken: site.jwt_token || '',\n  postStatus: site.post_status || 'draft',\n  \n  // Content\n  tone: site.tone || 'informative and engaging',\n  minWords: parseInt(site.min_words) || 1500,\n  maxWords: parseInt(site.max_words) || 2500,\n  faqCount: parseInt(site.faq_count) || 5,\n  \n  // Media\n  imagesCount: site.images_count !== undefined && site.images_count !== '' ? parseInt(site.images_count) : 2,\n  imageProvider: site.image_provider_priority ? site.image_provider_priority.split(',').map(s => s.trim().toLowerCase()).filter(s => s) : [],\n  \n  // Links\n  internalLinksCount: parseInt(site.internal_links_count) || 3,\n  externalLinksCount: parseInt(site.external_links_count) || 5,\n  youtubeCount: parseInt(site.youtube_embeds_count) || 1,\n  \n  // API Keys\n  openaiKey: globals.OPENAI_API_KEY || '',\n  openaiModel: globals.OPENAI_MODEL || 'gpt-4o-mini',\n  openaiImageModel: globals.OPENAI_IMAGE_MODEL || 'dall-e-3',\n  googleCseKey: globals.GOOGLE_CSE_API_KEY || '',\n  googleCseCx: globals.GOOGLE_CSE_CX || '',\n  youtubeKey: globals.YOUTUBE_API_KEY || '',\n  falKey: globals.FAL_API_KEY || '',\n  pexelsKey: globals.PEXELS_API_KEY || '',\n  \n  // Topic\n  topic,\n  tags: topicRow.tags || '',\n  categories: topicRow.categories || ''\n};\n\n// ============================================================\n// 3. HELPER FUNCTIONS\n// ============================================================\n\n// HTTP helper using n8n's httpRequest\nasync function httpRequest(options) {\n  return await this.helpers.httpRequest(options);\n}\n\n// Sleep helper\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// ============================================================\n// 4. WORDPRESS AUTHENTICATION\n// ============================================================\nasync function getWpAuthHeaders() {\n  if (config.authMode === 'jwt') {\n    // Try existing token first\n    if (config.jwtToken) {\n      const valid = await validateJwtToken(config.jwtToken);\n      if (valid) return { Authorization: `Bearer ${config.jwtToken}` };\n    }\n    // Get new token\n    const token = await getJwtToken();\n    if (token) return { Authorization: `Bearer ${token}` };\n    throw new Error('JWT authentication failed');\n  } else {\n    // Basic Auth\n    const creds = Buffer.from(`${config.wpUser}:${config.wpPassword}`).toString('base64');\n    return { Authorization: `Basic ${creds}` };\n  }\n}\n\nasync function validateJwtToken(token) {\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'POST',\n      url: `${config.baseUrl}/wp-json/jwt-auth/v1/token/validate`,\n      headers: { Authorization: `Bearer ${token}` }\n    });\n    return resp?.data?.status === 200 || resp?.code === 'jwt_auth_valid_token';\n  } catch {\n    return false;\n  }\n}\n\nasync function getJwtToken() {\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'POST',\n      url: `${config.baseUrl}/wp-json/jwt-auth/v1/token`,\n      body: {\n        username: config.jwtUser,\n        password: config.jwtPassword\n      },\n      headers: { 'Content-Type': 'application/json' },\n      returnFullResponse: true\n    });\n    const data = resp.body || resp;\n    return data?.token || null;\n  } catch (e) {\n    const errInfo = e.response?.data || e.response?.body || e.message;\n    throw new Error(`JWT token fetch failed: ${JSON.stringify(errInfo)}`);\n  }\n}\n\n// ============================================================\n// 5. CONTENT GENERATION\n// ============================================================\nasync function generateArticle() {\n  const systemPrompt = `You are an expert SEO content writer. Write comprehensive, engaging articles that rank well in search engines.\n\nRules:\n- Use proper HTML formatting (h2, h3, p, ul, li, strong, em)\n- Include an engaging introduction\n- Break content into logical sections with descriptive headings\n- Use bullet points and numbered lists where appropriate\n- Include ${config.faqCount} FAQs at the end in a dedicated section\n- Maintain a ${config.tone} tone throughout\n- Target ${config.minWords}-${config.maxWords} words\n- DO NOT include the title in the content (it will be added separately)\n- DO NOT include any image placeholders or references`;\n\n  const userPrompt = `Write a comprehensive blog article about: \"${config.topic}\"\n\nRequirements:\n1. Start with an engaging introduction paragraph\n2. Include 4-6 main sections with H2 headings\n3. Add subsections with H3 where appropriate\n4. Include practical tips, examples, or statistics\n5. End with ${config.faqCount} FAQs in a \"Frequently Asked Questions\" section\n6. Target word count: ${config.minWords}-${config.maxWords} words`;\n\n  const resp = await httpRequest.call(this, {\n    method: 'POST',\n    url: 'https://api.openai.com/v1/chat/completions',\n    headers: {\n      'Authorization': `Bearer ${config.openaiKey}`,\n      'Content-Type': 'application/json'\n    },\n    body: {\n      model: config.openaiModel,\n      messages: [\n        { role: 'system', content: systemPrompt },\n        { role: 'user', content: userPrompt }\n      ],\n      temperature: 0.7,\n      max_tokens: 4000\n    }\n  });\n\n  return resp?.choices?.[0]?.message?.content || '';\n}\n\nasync function generateTitle() {\n  const resp = await httpRequest.call(this, {\n    method: 'POST',\n    url: 'https://api.openai.com/v1/chat/completions',\n    headers: {\n      'Authorization': `Bearer ${config.openaiKey}`,\n      'Content-Type': 'application/json'\n    },\n    body: {\n      model: config.openaiModel,\n      messages: [\n        { role: 'system', content: 'Generate a single SEO-optimized blog title. Return ONLY the title, nothing else. No quotes, no explanation.' },\n        { role: 'user', content: `Generate a compelling title for a blog post about: ${config.topic}` }\n      ],\n      temperature: 0.8,\n      max_tokens: 100\n    }\n  });\n\n  return resp?.choices?.[0]?.message?.content?.trim() || config.topic;\n}\n\nasync function generateExcerpt(content) {\n  // Extract first paragraph for excerpt\n  const match = content.match(/<p>(.*?)<\\/p>/i);\n  if (match) {\n    const text = match[1].replace(/<[^>]+>/g, '');\n    return text.substring(0, 300) + (text.length > 300 ? '...' : '');\n  }\n  return config.topic;\n}\n\nasync function generateSlug(title) {\n  return title\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s-]/g, '')\n    .replace(/\\s+/g, '-')\n    .replace(/-+/g, '-')\n    .substring(0, 60);\n}\n\n// ============================================================\n// 6. IMAGE GENERATION/FETCHING\n// ============================================================\nconst imageErrors = [];\n\nasync function generateImage(prompt) {\n  for (const provider of config.imageProvider) {\n    try {\n      if (provider === 'openai' && config.openaiKey) {\n        const img = await generateImageOpenAI(prompt);\n        if (img) return { ...img, provider: 'openai' };\n      } else if (provider === 'fal' && config.falKey) {\n        const img = await generateImageFal(prompt);\n        if (img) return { ...img, provider: 'fal' };\n      } else if (provider === 'pexels' && config.pexelsKey) {\n        const img = await fetchImagePexels(prompt);\n        if (img) return { ...img, provider: 'pexels' };\n      }\n    } catch (e) {\n      imageErrors.push({ provider, error: e.message });\n    }\n  }\n  return null;\n}\n\nasync function generateImageOpenAI(prompt) {\n  const resp = await httpRequest.call(this, {\n    method: 'POST',\n    url: 'https://api.openai.com/v1/images/generations',\n    headers: {\n      'Authorization': `Bearer ${config.openaiKey}`,\n      'Content-Type': 'application/json'\n    },\n    body: {\n      model: config.openaiImageModel,\n      prompt: `Professional blog image: ${prompt}`,\n      n: 1,\n      size: '1024x1024',\n      response_format: 'b64_json'\n    }\n  });\n\n  const b64 = resp?.data?.[0]?.b64_json;\n  if (b64) {\n    return { base64: b64, mimeType: 'image/png' };\n  }\n  return null;\n}\n\nasync function generateImageFal(prompt) {\n  // Submit request\n  const submitResp = await httpRequest.call(this, {\n    method: 'POST',\n    url: 'https://queue.fal.run/fal-ai/flux/schnell',\n    headers: {\n      'Authorization': `Key ${config.falKey}`,\n      'Content-Type': 'application/json'\n    },\n    body: {\n      prompt: `Professional blog image: ${prompt}`,\n      image_size: 'landscape_16_9',\n      num_images: 1\n    }\n  });\n\n  const requestId = submitResp?.request_id;\n  if (!requestId) return null;\n\n  // Poll for result\n  for (let i = 0; i < 30; i++) {\n    await sleep(2000);\n    const statusResp = await httpRequest.call(this, {\n      method: 'GET',\n      url: `https://queue.fal.run/fal-ai/flux/schnell/requests/${requestId}/status`,\n      headers: { 'Authorization': `Key ${config.falKey}` }\n    });\n\n    if (statusResp?.status === 'COMPLETED') {\n      const resultResp = await httpRequest.call(this, {\n        method: 'GET',\n        url: `https://queue.fal.run/fal-ai/flux/schnell/requests/${requestId}`,\n        headers: { 'Authorization': `Key ${config.falKey}` }\n      });\n      const imgUrl = resultResp?.images?.[0]?.url;\n      if (imgUrl) {\n        return { url: imgUrl };\n      }\n    } else if (statusResp?.status === 'FAILED') {\n      break;\n    }\n  }\n  return null;\n}\n\nasync function fetchImagePexels(query) {\n  const resp = await httpRequest.call(this, {\n    method: 'GET',\n    url: `https://api.pexels.com/v1/search?query=${encodeURIComponent(query)}&per_page=5`,\n    headers: { 'Authorization': config.pexelsKey }\n  });\n\n  const photos = resp?.photos || [];\n  if (photos.length > 0) {\n    const photo = photos[Math.floor(Math.random() * photos.length)];\n    return {\n      url: photo.src?.large || photo.src?.original,\n      attribution: `Photo by ${photo.photographer} on Pexels`\n    };\n  }\n  return null;\n}\n\n// ============================================================\n// 7. UPLOAD IMAGE TO WORDPRESS\n// ============================================================\nasync function uploadImageToWp(imageData, filename) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  let buffer;\n  let contentType = 'image/png';\n\n  if (imageData.base64) {\n    buffer = Buffer.from(imageData.base64, 'base64');\n  } else if (imageData.url) {\n    const imgResp = await httpRequest.call(this, {\n      method: 'GET',\n      url: imageData.url,\n      encoding: 'arraybuffer',\n      returnFullResponse: true\n    });\n    buffer = Buffer.from(imgResp.body);\n    contentType = imgResp.headers['content-type'] || 'image/jpeg';\n  }\n\n  if (!buffer) return null;\n\n  const ext = contentType.includes('png') ? 'png' : 'jpg';\n  const fname = `${filename}.${ext}`;\n\n  const uploadResp = await httpRequest.call(this, {\n    method: 'POST',\n    url: `${config.baseUrl}/wp-json/wp/v2/media`,\n    headers: {\n      ...authHeaders,\n      'Content-Type': contentType,\n      'Content-Disposition': `attachment; filename=\"${fname}\"`\n    },\n    body: buffer\n  });\n\n  return uploadResp?.id || null;\n}\n\n// ============================================================\n// 8. EXTERNAL LINKS (Google Custom Search)\n// ============================================================\nasync function fetchExternalLinks() {\n  if (!config.googleCseKey || !config.googleCseCx || config.externalLinksCount === 0) {\n    return [];\n  }\n\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'GET',\n      url: `https://www.googleapis.com/customsearch/v1?key=${config.googleCseKey}&cx=${config.googleCseCx}&q=${encodeURIComponent(config.topic)}&num=${Math.min(config.externalLinksCount + 2, 10)}`\n    });\n\n    return (resp?.items || []).slice(0, config.externalLinksCount).map(item => ({\n      title: item.title,\n      url: item.link,\n      snippet: item.snippet\n    }));\n  } catch (e) {\n    console.error('CSE error:', e.message);\n    return [];\n  }\n}\n\n// ============================================================\n// 9. YOUTUBE VIDEOS\n// ============================================================\nasync function fetchYouTubeVideos() {\n  if (!config.youtubeKey || config.youtubeCount === 0) {\n    return [];\n  }\n\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'GET',\n      url: `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(config.topic)}&type=video&maxResults=${config.youtubeCount}&key=${config.youtubeKey}`\n    });\n\n    return (resp?.items || []).map(item => ({\n      videoId: item.id?.videoId,\n      title: item.snippet?.title,\n      embedHtml: `<div class=\"youtube-embed\" style=\"position:relative;padding-bottom:56.25%;height:0;overflow:hidden;max-width:100%;margin:20px 0;\"><iframe style=\"position:absolute;top:0;left:0;width:100%;height:100%;\" src=\"https://www.youtube.com/embed/${item.id?.videoId}\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></div>`\n    }));\n  } catch (e) {\n    console.error('YouTube error:', e.message);\n    return [];\n  }\n}\n\n// ============================================================\n// 10. INTERNAL LINKS\n// ============================================================\nasync function fetchInternalLinks() {\n  if (config.internalLinksCount === 0) return [];\n\n  try {\n    const authHeaders = await getWpAuthHeaders.call(this);\n    const resp = await httpRequest.call(this, {\n      method: 'GET',\n      url: `${config.baseUrl}/wp-json/wp/v2/posts?per_page=${config.internalLinksCount + 5}&orderby=date&order=desc`,\n      headers: authHeaders\n    });\n\n    return (resp || []).slice(0, config.internalLinksCount).map(post => ({\n      title: post.title?.rendered || 'Related Post',\n      url: post.link\n    }));\n  } catch (e) {\n    console.error('Internal links error:', e.message);\n    return [];\n  }\n}\n\n// ============================================================\n// 11. CONTENT ENRICHMENT (Insert links, videos, images)\n// ============================================================\nfunction injectExternalLinks(content, links) {\n  if (!links || links.length === 0) return { content, inserted: 0 };\n\n  let inserted = 0;\n  let paragraphs = content.split(/<\\/p>/gi);\n  \n  // Calculate positions to insert links (spread throughout content)\n  const totalParagraphs = paragraphs.length;\n  const interval = Math.max(2, Math.floor(totalParagraphs / (links.length + 1)));\n  \n  links.forEach((link, idx) => {\n    const targetPos = Math.min((idx + 1) * interval, paragraphs.length - 1);\n    \n    // Find a paragraph that doesn't already have a link\n    for (let i = targetPos; i < paragraphs.length; i++) {\n      if (paragraphs[i] && !paragraphs[i].includes('<a ') && paragraphs[i].trim().length > 50) {\n        const linkHtml = ` <a href=\"${link.url}\" target=\"_blank\" rel=\"noopener\">${link.title}</a>`;\n        // Insert before closing tag\n        paragraphs[i] = paragraphs[i].trimEnd() + ` For more information, see${linkHtml}.`;\n        inserted++;\n        break;\n      }\n    }\n  });\n\n  return { content: paragraphs.join('</p>'), inserted };\n}\n\nfunction injectYouTubeVideos(content, videos) {\n  if (!videos || videos.length === 0) return content;\n\n  // Find h2 tags and insert videos after them\n  const h2Matches = [...content.matchAll(/<\\/h2>/gi)];\n  \n  videos.forEach((video, idx) => {\n    if (h2Matches[idx + 1]) {\n      const pos = h2Matches[idx + 1].index + 5;\n      content = content.slice(0, pos) + video.embedHtml + content.slice(pos);\n    } else {\n      // Fallback: add before FAQ section or at end\n      const faqMatch = content.match(/<h2[^>]*>.*?faq.*?<\\/h2>/i);\n      if (faqMatch) {\n        content = content.replace(faqMatch[0], video.embedHtml + faqMatch[0]);\n      } else {\n        content += video.embedHtml;\n      }\n    }\n  });\n\n  return content;\n}\n\nfunction injectInternalLinks(content, links) {\n  if (!links || links.length === 0) return content;\n\n  // Add \"Related Posts\" section before FAQ\n  const relatedHtml = `\n<div class=\"related-posts\" style=\"background:#f5f5f5;padding:20px;margin:20px 0;border-radius:8px;\">\n  <h3>Related Articles</h3>\n  <ul>\n    ${links.map(l => `<li><a href=\"${l.url}\">${l.title}</a></li>`).join('\\n    ')}\n  </ul>\n</div>`;\n\n  const faqMatch = content.match(/<h2[^>]*>.*?faq.*?<\\/h2>/i);\n  if (faqMatch) {\n    return content.replace(faqMatch[0], relatedHtml + faqMatch[0]);\n  }\n  return content + relatedHtml;\n}\n\n// ============================================================\n// 12. PUBLISH TO WORDPRESS (with detailed error capture)\n// ============================================================\nasync function publishPost(title, content, excerpt, slug, featuredImageId) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  \n  const postData = {\n    title,\n    content,\n    excerpt,\n    slug,\n    status: config.postStatus,\n    comment_status: 'open',\n    ping_status: 'open'\n  };\n\n  if (featuredImageId) {\n    postData.featured_media = featuredImageId;\n  }\n\n  // Handle categories\n  if (config.categories) {\n    try {\n      const catIds = await getOrCreateTerms.call(this, 'categories', config.categories);\n      if (catIds.length > 0) postData.categories = catIds;\n    } catch (catErr) {\n      executionLog.push({ step: 'CATEGORIES', status: 'error', error: catErr.message });\n    }\n  }\n\n  // Handle tags\n  if (config.tags) {\n    try {\n      const tagIds = await getOrCreateTerms.call(this, 'tags', config.tags);\n      if (tagIds.length > 0) postData.tags = tagIds;\n    } catch (tagErr) {\n      executionLog.push({ step: 'TAGS', status: 'error', error: tagErr.message });\n    }\n  }\n\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'POST',\n      url: `${config.baseUrl}/wp-json/wp/v2/posts`,\n      headers: {\n        ...authHeaders,\n        'Content-Type': 'application/json'\n      },\n      body: postData,\n      returnFullResponse: true\n    });\n    return resp.body || resp;\n  } catch (httpErr) {\n    // Capture detailed error info from WordPress\n    const errDetail = {\n      message: httpErr.message,\n      statusCode: httpErr.response?.status || httpErr.statusCode,\n      wpError: httpErr.response?.data || httpErr.response?.body,\n      endpoint: `${config.baseUrl}/wp-json/wp/v2/posts`,\n      sentData: { title: title?.substring(0, 50), contentLength: content?.length, slug }\n    };\n    throw new Error(`WP POST failed: ${JSON.stringify(errDetail)}`);\n  }\n}\n\nasync function getOrCreateTerms(taxonomy, termString) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  const termNames = termString.split(',').map(t => t.trim()).filter(t => t);\n  const ids = [];\n\n  const endpoint = taxonomy === 'categories' ? 'categories' : 'tags';\n\n  for (const name of termNames) {\n    try {\n      // Search for existing term\n      const searchResp = await httpRequest.call(this, {\n        method: 'GET',\n        url: `${config.baseUrl}/wp-json/wp/v2/${endpoint}?search=${encodeURIComponent(name)}`,\n        headers: authHeaders\n      });\n\n      const existing = (searchResp || []).find(t => \n        t.name.toLowerCase() === name.toLowerCase()\n      );\n\n      if (existing) {\n        ids.push(existing.id);\n      } else {\n        // Create new term\n        const createResp = await httpRequest.call(this, {\n          method: 'POST',\n          url: `${config.baseUrl}/wp-json/wp/v2/${endpoint}`,\n          headers: { ...authHeaders, 'Content-Type': 'application/json' },\n          body: { name }\n        });\n        if (createResp?.id) ids.push(createResp.id);\n      }\n    } catch (e) {\n      console.error(`Term error (${name}):`, e.message);\n    }\n  }\n\n  return ids;\n}\n\n// ============================================================\n// 13. MAIN EXECUTION (with detailed step tracking)\n// ============================================================\nconst executionLog = [];\nlet currentStep = '';\n\ntry {\n  // Step 1: Generate content\n  currentStep = 'GENERATE_CONTENT';\n  executionLog.push({ step: currentStep, status: 'started', time: new Date().toISOString() });\n  \n  const [title, article] = await Promise.all([\n    generateTitle.call(this),\n    generateArticle.call(this)\n  ]);\n  executionLog.push({ step: currentStep, status: 'completed', title: title?.substring(0, 50) });\n\n  if (!article) {\n    return [{ json: { ok: false, error: 'Failed to generate article content', step: currentStep, log: executionLog } }];\n  }\n\n  // Step 2: Fetch enrichments\n  currentStep = 'FETCH_ENRICHMENTS';\n  executionLog.push({ step: currentStep, status: 'started' });\n  \n  const [externalLinks, youtubeVideos, internalLinks] = await Promise.all([\n    fetchExternalLinks.call(this),\n    fetchYouTubeVideos.call(this),\n    fetchInternalLinks.call(this)\n  ]);\n  executionLog.push({ step: currentStep, status: 'completed', counts: { external: externalLinks.length, youtube: youtubeVideos.length, internal: internalLinks.length } });\n\n  // Step 3: Enrich content\n  currentStep = 'ENRICH_CONTENT';\n  let enrichedContent = article;\n  const linkResult = injectExternalLinks(enrichedContent, externalLinks);\n  enrichedContent = linkResult.content;\n  enrichedContent = injectYouTubeVideos(enrichedContent, youtubeVideos);\n  enrichedContent = injectInternalLinks(enrichedContent, internalLinks);\n  executionLog.push({ step: currentStep, status: 'completed' });\n\n  // Step 4: Generate images (skipped if count is 0)\n  currentStep = 'GENERATE_IMAGES';\n  let featuredImageId = null;\n  \n  if (config.imagesCount > 0) {\n    executionLog.push({ step: currentStep, status: 'started', count: config.imagesCount });\n    const imagePrompts = [\n      `${config.topic} - professional hero image`,\n      `${config.topic} - detailed illustration`\n    ];\n\n    for (let i = 0; i < Math.min(config.imagesCount, imagePrompts.length); i++) {\n      const img = await generateImage.call(this, imagePrompts[i]);\n      if (img) {\n        const imgSlug = await generateSlug(title);\n        const imageId = await uploadImageToWp.call(this, img, `${imgSlug}-${i + 1}`);\n        if (imageId && i === 0) {\n          featuredImageId = imageId;\n        }\n      }\n    }\n    executionLog.push({ step: currentStep, status: 'completed', featuredImageId });\n  } else {\n    executionLog.push({ step: currentStep, status: 'skipped', reason: 'images_count=0' });\n  }\n\n  // Step 5: Generate slug and excerpt\n  currentStep = 'GENERATE_META';\n  const slug = await generateSlug(title);\n  const excerpt = await generateExcerpt(enrichedContent);\n  executionLog.push({ step: currentStep, status: 'completed', slug });\n\n  // Step 6: Test WordPress auth first\n  currentStep = 'TEST_WP_AUTH';\n  executionLog.push({ step: currentStep, status: 'started' });\n  try {\n    const authHeaders = await getWpAuthHeaders.call(this);\n    executionLog.push({ step: currentStep, status: 'completed', authType: config.authMode });\n  } catch (authErr) {\n    return [{ json: { ok: false, error: `WordPress auth failed: ${authErr.message}`, step: currentStep, log: executionLog, site, topicRow } }];\n  }\n\n  // Step 7: Publish post\n  currentStep = 'PUBLISH_POST';\n  executionLog.push({ step: currentStep, status: 'started', url: `${config.baseUrl}/wp-json/wp/v2/posts` });\n  \n  const postResp = await publishPost.call(this, title, enrichedContent, excerpt, slug, featuredImageId);\n\n  if (!postResp?.id) {\n    return [{ json: { ok: false, error: 'Failed to create WordPress post', step: currentStep, debug: postResp, log: executionLog } }];\n  }\n  executionLog.push({ step: currentStep, status: 'completed', postId: postResp.id });\n\n  // Success response\n  return [{\n    json: {\n      ok: true,\n      post_id: postResp.id,\n      post_url: postResp.link,\n      title,\n      slug,\n      status: postResp.status,\n      featured_image_id: featuredImageId,\n      enrichment: {\n        external_links: externalLinks.length,\n        external_links_inserted: linkResult.inserted,\n        youtube_videos: youtubeVideos.length,\n        internal_links: internalLinks.length\n      },\n      image_errors: imageErrors,\n      execution_log: executionLog,\n      site: site,\n      topicRow: topicRow\n    }\n  }];\n\n} catch (error) {\n  executionLog.push({ step: currentStep, status: 'FAILED', error: error.message });\n  return [{\n    json: {\n      ok: false,\n      error: error.message,\n      failed_at_step: currentStep,\n      execution_log: executionLog,\n      stack: error.stack,\n      site: site,\n      topicRow: topicRow\n    }\n  }];\n}\n"
      },
      "id": "engine-001",
      "name": "Publisher Engine (Code)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 0]
    }
  ],
  "connections": {
    "Execute Workflow Trigger": {
      "main": [[{ "node": "Inject Globals", "type": "main", "index": 0 }]]
    },
    "Inject Globals": {
      "main": [[{ "node": "Publisher Engine (Code)", "type": "main", "index": 0 }]]
    }
  },
  "active": false,
  "settings": { "executionOrder": "v1" },
  "versionId": "v2-clean-001",
  "meta": { "templateId": "autoblogger-publisher-v2" },
  "tags": []
}

