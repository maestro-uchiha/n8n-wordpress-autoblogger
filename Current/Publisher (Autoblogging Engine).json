{
  "name": "2. Publisher (Autoblogger Engine)",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "id": "trigger-pub-001",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "/**\n * Inject Globals - Merge incoming data with n8n variables\n */\nconst vars = {\n  OPENAI_API_KEY: $vars.OPENAI_API_KEY || '',\n  OPENAI_MODEL: $vars.OPENAI_MODEL || 'gpt-4o-mini',\n  OPENAI_IMAGE_MODEL: $vars.OPENAI_IMAGE_MODEL || 'dall-e-2',\n  GOOGLE_CSE_API_KEY: $vars.GOOGLE_CSE_API_KEY || '',\n  GOOGLE_CSE_CX: $vars.GOOGLE_CSE_CX || '',\n  YOUTUBE_API_KEY: $vars.YOUTUBE_API_KEY || '',\n  FAL_API_KEY: $vars.FAL_API_KEY || '',\n  FAL_MODEL: $vars.FAL_MODEL || 'fal-ai/flux/schnell',\n  PEXELS_API_KEY: $vars.PEXELS_API_KEY || '',\n  IMAGE_PROVIDER_PRIORITY_DEFAULT: $vars.IMAGE_PROVIDER_PRIORITY_DEFAULT || 'fal,pexels,openai',\n  SPEEDYINDEX_API_KEY: $vars.SPEEDYINDEX_API_KEY || '',\n  TELEGRAM_BOT_TOKEN: $vars.TELEGRAM_BOT_TOKEN || '',\n  TELEGRAM_CHAT_ID: $vars.TELEGRAM_CHAT_ID || '',\n  NOTIFICATION_EMAIL: $vars.NOTIFICATION_EMAIL || '',\n  EMAIL_FROM: $vars.EMAIL_FROM || 'noreply@autoblogger.local',\n  EMAIL_PROVIDER: $vars.EMAIL_PROVIDER || '',\n  RESEND_API_KEY: $vars.RESEND_API_KEY || '',\n  SENDGRID_API_KEY: $vars.SENDGRID_API_KEY || '',\n  MAILGUN_API_KEY: $vars.MAILGUN_API_KEY || '',\n  MAILGUN_DOMAIN: $vars.MAILGUN_DOMAIN || '',\n  SMTP2GO_API_KEY: $vars.SMTP2GO_API_KEY || ''\n};\n\nreturn [{\n  json: {\n    globals: vars,\n    ...($json || {})\n  }\n}];\n"
      },
      "id": "inject-globals-001",
      "name": "Inject Globals",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        220,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "/**\n * AUTOBLOGGER PUBLISHER ENGINE v2.40\n * \n * v2.40 Changes:\n * - FIX: YouTube now uses plain URL (WordPress auto-embeds perfectly)\n * - FIX: Detects if AI stacked image placeholders and redistributes them by H2\n * \n * v2.39 Changes:\n * - Simplified YouTube embed format\n * \n * v2.38 Changes:\n * - YouTube embeds use [embed] shortcode (iframes stripped by wp_kses)\n * \n * v2.37 Changes:\n * - FIX: Empty string handling for internal_links_count/external_links_count (was causing NaN)\n * \n * v2.36 Changes:\n * - YouTube/Images placed by AI using placeholder comments\n * \n * v2.30 Changes:\n * - SEO: New plugin endpoint /n8n/v1/update-seo-meta for direct meta updates\n * - SEO: Shows which SEO plugins are detected (Yoast/RankMath)\n * - SEO: Uses update_post_meta() directly (bypasses REST API schema restrictions)\n * \n * v2.29 Changes:\n * - FIX: Removed JSON-LD script injection (WordPress blocks script tags)\n */\n\nfunction parseInput(json) {\n  let site = json.site_config || json.site || json.siteConfig || {};\n  let topicRow = json.topicRow || json.topic_row || json.row || {};\n  let globals = json.globals || {};\n  if (!site.base_url && json.base_url) site = json;\n  let topic = topicRow.topic || topicRow.keyword || json.topic || json.keyword || '';\n  return { site, topicRow, globals, topic };\n}\n\nconst input = $input.first().json;\nconst { site, topicRow, globals, topic } = parseInput(input);\n\nconst executionLog = [];\nconst debug = {\n  serp_count: 0,\n  youtube_candidates_count: 0,\n  images_requested: 0,\n  images_uploaded: 0,\n  images_by_provider: {},\n  internal_links_requested: 0,\n  internal_links_inserted: 0,\n  external_links_requested: 0,\n  external_links_inserted: 0,\n  youtube_embeds_requested: 0,\n  youtube_embeds_inserted: 0,\n  categories_requested: [],\n  categories_found: [],\n  notifications: { speedyindex: false, telegram: false, email: false },\n  seo_meta_updated: false,\n  seo_plugins: {},\n  image_errors: [],\n  wp_errors: []\n};\nlet currentStep = '';\n\nif (!topic) return [{ json: { ok: false, error: 'Missing topic', debug: { input } } }];\nif (!site.base_url) return [{ json: { ok: false, error: 'Missing site base_url', debug: { site, input } } }];\nif (!globals.OPENAI_API_KEY) return [{ json: { ok: false, error: 'CRITICAL: OPENAI_API_KEY is missing', site, topicRow } }];\n\n// Helper to parse boolean from various formats\nfunction parseBool(val, defaultVal = false) {\n  if (val === undefined || val === null || val === '') return defaultVal;\n  if (typeof val === 'boolean') return val;\n  if (typeof val === 'string') {\n    const lower = val.toLowerCase().trim();\n    if (lower === 'true' || lower === 'yes' || lower === '1') return true;\n    if (lower === 'false' || lower === 'no' || lower === '0') return false;\n  }\n  return defaultVal;\n}\n\nfunction detectEmailProvider(globals) {\n  if (globals.EMAIL_PROVIDER) return globals.EMAIL_PROVIDER.toLowerCase();\n  if (globals.RESEND_API_KEY) return 'resend';\n  if (globals.SENDGRID_API_KEY) return 'sendgrid';\n  if (globals.MAILGUN_API_KEY && globals.MAILGUN_DOMAIN) return 'mailgun';\n  if (globals.SMTP2GO_API_KEY) return 'smtp2go';\n  return null;\n}\n\nconst config = {\n  baseUrl: site.base_url.replace(/\\/$/, ''),\n  authMode: (site.auth_mode || 'jwt').toLowerCase(),\n  wpUser: site.wp_user || site.jwt_user || '',\n  wpPassword: site.wp_app_password || '',\n  jwtUser: site.jwt_user || '',\n  jwtPassword: site.jwt_password || '',\n  jwtToken: site.jwt_token || '',\n  jwtTokenEndpoint: site.jwt_token_endpoint || null,\n  postStatus: site.post_status || 'draft',\n  tone: site.tone || 'informative and engaging',\n  minWords: parseInt(site.min_words) || 1500,\n  maxWords: parseInt(site.max_words) || 2500,\n  faqCount: parseInt(site.faq_count) || 5,\n  imagesCount: (() => {\n    // v2.33: Support images_min/images_max range (random) or single images_count\n    const min = parseInt(site.images_min);\n    const max = parseInt(site.images_max);\n    if (!isNaN(min) && !isNaN(max) && min <= max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return site.images_count !== undefined && site.images_count !== '' ? parseInt(site.images_count) : 0;\n  })(),\n  imageProvider: site.image_provider_priority \n    ? site.image_provider_priority.split(',').map(s => s.trim().toLowerCase()).filter(s => s) \n    : (globals.IMAGE_PROVIDER_PRIORITY_DEFAULT || 'fal,pexels,openai').split(',').map(s => s.trim().toLowerCase()).filter(s => s),\n  internalLinksCount: (() => {\n    const min = parseInt(site.internal_links_min);\n    const max = parseInt(site.internal_links_max);\n    if (!isNaN(min) && !isNaN(max) && min <= max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return site.internal_links_count !== undefined && site.internal_links_count !== '' ? parseInt(site.internal_links_count) : 3;\n  })(),\n  externalLinksCount: (() => {\n    const min = parseInt(site.external_links_min);\n    const max = parseInt(site.external_links_max);\n    if (!isNaN(min) && !isNaN(max) && min <= max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return site.external_links_count !== undefined && site.external_links_count !== '' ? parseInt(site.external_links_count) : 5;\n  })(),\n  youtubeCount: (() => {\n    const min = parseInt(site.youtube_embeds_min);\n    const max = parseInt(site.youtube_embeds_max);\n    if (!isNaN(min) && !isNaN(max) && min <= max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return site.youtube_embeds_count !== undefined && site.youtube_embeds_count !== '' ? parseInt(site.youtube_embeds_count) : 1;\n  })(),\n  defaultCategory: site.default_category || '',\n  \n  // Per-site notification controls (v2.8)\n  speedyindexEnabled: parseBool(site.speedyindex_enabled, false),\n  telegramEnabled: parseBool(site.telegram_enabled, true),\n  emailEnabled: parseBool(site.email_enabled, false),\n  \n  openaiKey: globals.OPENAI_API_KEY,\n  openaiModel: site.openai_model || globals.OPENAI_MODEL || 'gpt-4o-mini',\n  openaiImageModel: site.openai_image_model || globals.OPENAI_IMAGE_MODEL || 'dall-e-2',\n  falModel: site.fal_model || globals.FAL_MODEL || 'fal-ai/flux/schnell',\n  googleCseKey: globals.GOOGLE_CSE_API_KEY || '',\n  googleCseCx: globals.GOOGLE_CSE_CX || '',\n  youtubeKey: globals.YOUTUBE_API_KEY || '',\n  pexelsKey: globals.PEXELS_API_KEY || '',\n  falKey: globals.FAL_API_KEY || '',\n  speedyIndexKey: globals.SPEEDYINDEX_API_KEY || '',\n  telegramToken: globals.TELEGRAM_BOT_TOKEN || '',\n  telegramChatId: globals.TELEGRAM_CHAT_ID || '',\n  notificationEmail: globals.NOTIFICATION_EMAIL || '',\n  emailFrom: globals.EMAIL_FROM || 'noreply@autoblogger.local',\n  emailProvider: detectEmailProvider(globals),\n  resendApiKey: globals.RESEND_API_KEY || '',\n  sendgridApiKey: globals.SENDGRID_API_KEY || '',\n  mailgunApiKey: globals.MAILGUN_API_KEY || '',\n  mailgunDomain: globals.MAILGUN_DOMAIN || '',\n  smtp2goApiKey: globals.SMTP2GO_API_KEY || '',\n  topic,\n  tags: topicRow.tags || '',\n  categories: topicRow.categories || topicRow.category || ''\n};\n\ndebug.images_requested = config.imagesCount;\ndebug.internal_links_requested = config.internalLinksCount;\ndebug.external_links_requested = config.externalLinksCount;\ndebug.youtube_embeds_requested = config.youtubeCount;\n\nasync function httpRequest(options) {\n  return await this.helpers.httpRequest(options);\n}\n\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nlet cachedAuthHeaders = null;\n\nasync function getWpAuthHeaders() {\n  if (cachedAuthHeaders) return cachedAuthHeaders;\n  if (config.authMode === 'jwt') {\n    if (config.jwtToken) {\n      const valid = await validateJwtToken.call(this, config.jwtToken);\n      if (valid) {\n        cachedAuthHeaders = { Authorization: `Bearer ${config.jwtToken}` };\n        return cachedAuthHeaders;\n      }\n    }\n    const token = await getJwtToken.call(this);\n    if (token) {\n      cachedAuthHeaders = { Authorization: `Bearer ${token}` };\n      return cachedAuthHeaders;\n    }\n    throw new Error('JWT authentication failed');\n  } else {\n    const creds = Buffer.from(`${config.wpUser}:${config.wpPassword}`).toString('base64');\n    cachedAuthHeaders = { Authorization: `Basic ${creds}` };\n    return cachedAuthHeaders;\n  }\n}\n\nasync function validateJwtToken(token) {\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'POST',\n      url: `${config.baseUrl}/wp-json/jwt-auth/v1/token/validate`,\n      headers: { Authorization: `Bearer ${token}` }\n    });\n    return resp?.data?.status === 200 || resp?.code === 'jwt_auth_valid_token';\n  } catch { return false; }\n}\n\nasync function getJwtToken() {\n  const endpoint = config.jwtTokenEndpoint || `${config.baseUrl}/wp-json/jwt-auth/v1/token`;\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'POST',\n      url: endpoint,\n      body: { username: config.jwtUser, password: config.jwtPassword },\n      headers: { 'Content-Type': 'application/json' }\n    });\n    return resp?.token || null;\n  } catch (e) {\n    throw new Error(`JWT token fetch failed: ${e.message}`);\n  }\n}\n\nasync function wpAuthSanityCheck() {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  const resp = await httpRequest.call(this, {\n    method: 'GET',\n    url: `${config.baseUrl}/wp-json/wp/v2/users/me`,\n    headers: authHeaders\n  });\n  if (!resp?.id) throw new Error('No user ID in response');\n  return { ok: true, user: resp.name || resp.slug };\n}\n\nasync function fetchSerpHints() {\n  if (!config.googleCseKey || !config.googleCseCx) return [];\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'GET',\n      url: `https://www.googleapis.com/customsearch/v1?key=${config.googleCseKey}&cx=${config.googleCseCx}&q=${encodeURIComponent(config.topic)}&num=10`\n    });\n    const results = (resp?.items || []).map(item => ({ title: item.title, url: item.link, snippet: item.snippet }));\n    debug.serp_count = results.length;\n    return results;\n  } catch (e) {\n    debug.wp_errors.push({ step: 'SERP', error: e.message });\n    return [];\n  }\n}\n\nasync function fetchYouTubeCandidates() {\n  if (!config.youtubeKey || config.youtubeCount === 0) return [];\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'GET',\n      url: `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(config.topic)}&type=video&maxResults=5&key=${config.youtubeKey}`\n    });\n    const results = (resp?.items || []).map(item => ({\n      videoId: item.id?.videoId,\n      title: item.snippet?.title || 'Related Video',\n      url: `https://www.youtube.com/watch?v=${item.id?.videoId}`\n    }));\n    debug.youtube_candidates_count = results.length;\n    return results;\n  } catch (e) {\n    debug.wp_errors.push({ step: 'YOUTUBE', error: e.message });\n    return [];\n  }\n}\n\nasync function generateContentJson() {\n  const imagePlaceholderInstructions = config.imagesCount > 0 \n    ? `\\n\\nIMAGE PLACEHOLDERS (REQUIRED):\\nYou MUST include EXACTLY ${config.imagesCount} image placeholder(s) in the content_html.\\nFormat: <!-- WPIMG alt=\"DESCRIPTIVE ALT TEXT HERE\" -->\\nPLACEMENT: Place each image where it would naturally enhance the reader's understanding - after explaining a concept, showing a process, or introducing a new section. Space them throughout the article.\\nEach ALT text must be unique and descriptive of what the image should show.`\n    : '';\n\n  const youtubePlaceholderInstructions = config.youtubeCount > 0 \n    ? `\\n\\nYOUTUBE PLACEHOLDERS (REQUIRED):\\nYou MUST include EXACTLY ${config.youtubeCount} YouTube placeholder(s) in the content_html.\\nFormat: <!-- YTVID context=\"DESCRIPTION OF WHAT VIDEO SHOULD COVER\" -->\\nPLACEMENT: Place each placeholder where a video tutorial, demonstration, or explanation would naturally fit - such as after introducing a technique, explaining a complex concept, or in a how-to section.\\nEach context description should be unique and relate to the surrounding content.`\n    : '';\n\n  const systemPrompt = `You are an expert SEO content writer. You MUST respond with ONLY valid JSON, no other text.\n\nOutput JSON schema:\n{\n  \"title\": \"SEO-optimized title\",\n  \"slug\": \"url-friendly-slug\",\n  \"meta_description\": \"150-160 char meta description\",\n  \"focus_keyphrase\": \"main keyword/phrase to rank for\",\n  \"tag_suggestions\": [\"tag1\", \"tag2\"],\n  \"content_html\": \"<p>Full HTML content...</p>\",\n  \"internal_anchor_phrases\": [\"phrase for internal links\"],\n  \"external_anchor_phrases\": [\"phrase for external links\"],\n  \"youtube_anchor_phrases\": [\"phrase near youtube embed spots\"],\n  \"faq_items\": [{\"question\": \"FAQ question?\", \"answer\": \"Answer text\"}]\n}\n\nCRITICAL RULES - MUST FOLLOW:\n- ABSOLUTELY NO <a> tags or href attributes in content_html - links will be added programmatically later\n- ABSOLUTELY NO URLs in content_html - no example.com, no placeholder links, no references\n- ABSOLUTELY NO \"Learn more\", \"Read more\", \"Click here\" or similar link text\n- NO citations, sources, or references sections\n- Link anchor phrases must appear ONLY in paragraph text (<p>, <li>), NEVER in headings (<h2>, <h3>)\n\nContent rules:\n- Use proper HTML: h2, h3, p, ul, li, ol, strong, em, table, thead, tbody, tr, th, td\n- INCLUDE AT LEAST ONE DATA TABLE (comparisons, specs, statistics, pros/cons)\n- Tables should have proper thead with th headers and tbody with td cells\n- Include ${config.faqCount} FAQs at the end (also return them in faq_items array for schema)\n- Target ${config.minWords}-${config.maxWords} words\n- Tone: ${config.tone}\n- NO title in content_html (title goes in the title field)\n- Anchor phrases MUST appear verbatim as plain text in PARAGRAPH content (NOT in headings)\n- focus_keyphrase should appear naturally 3-5 times in the content${imagePlaceholderInstructions}${youtubePlaceholderInstructions}`;\n\n  const userPrompt = `Write a comprehensive blog article about: \"${config.topic}\"\n\nProvide:\\n1. Engaging introduction\\n2. 4-6 main sections with H2 headings\\n3. Subsections with H3 where appropriate\\n4. AT LEAST ONE HTML TABLE with data\\n5. Practical tips and examples\\n6. ${config.faqCount} FAQs at the end (also in faq_items array)\\n7. ${Math.max(3, config.internalLinksCount)} internal_anchor_phrases (phrases that appear in PARAGRAPHS only)\\n8. ${Math.max(3, config.externalLinksCount)} external_anchor_phrases (phrases that appear in PARAGRAPHS only)\\n9. ${Math.max(2, config.youtubeCount)} youtube_anchor_phrases\\n10. focus_keyphrase (main SEO keyword derived from topic)\\n\\nIMPORTANT: All anchor phrases must appear in <p> or <li> tags, NOT in headings.\\n\\nRespond with ONLY the JSON object.`;\n\n  const resp = await httpRequest.call(this, {\n    method: 'POST',\n    url: 'https://api.openai.com/v1/chat/completions',\n    headers: { 'Authorization': `Bearer ${config.openaiKey}`, 'Content-Type': 'application/json' },\n    body: {\n      model: config.openaiModel,\n      messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }],\n      temperature: 0.7,\n      max_tokens: 4500,\n      response_format: { type: 'json_object' }\n    }\n  });\n\n  const content = resp?.choices?.[0]?.message?.content;\n  if (!content) throw new Error('Empty response from OpenAI');\n  const parsed = JSON.parse(content);\n  \n  // Strip any hallucinated links from content_html (AI sometimes ignores instructions)\n  if (parsed.content_html) {\n    // Remove any <a> tags, keeping their inner text\n    parsed.content_html = parsed.content_html.replace(/<a[^>]*>([^<]*)<\\/a>/gi, '$1');\n    // Remove any remaining href attributes (shouldn't happen but safety)\n    parsed.content_html = parsed.content_html.replace(/href=\"[^\"]*\"/gi, '');\n    // Remove placeholder URLs that might appear as text\n    parsed.content_html = parsed.content_html.replace(/https?:\\/\\/example\\.com[^\\s<]*/gi, '');\n    parsed.content_html = parsed.content_html.replace(/https?:\\/\\/www\\.example\\.com[^\\s<]*/gi, '');\n  }\n  \n  return parsed;\n}\n\nfunction validateContent(contentJson) {\n  const errors = [];\n  if (!contentJson.title) errors.push('Missing title');\n  if (!contentJson.content_html) errors.push('Missing content_html');\n  if (!contentJson.meta_description) errors.push('Missing meta_description');\n  // v2.32: Image placeholder check is now a warning, not an error\n  // AI sometimes doesn't include enough placeholders - we proceed with what we have\n  if (config.imagesCount > 0) {\n    const placeholderMatches = contentJson.content_html.match(/<!-- WPIMG alt=\"[^\"]+\" -->/g) || [];\n    if (placeholderMatches.length < config.imagesCount) {\n      debug.wp_errors.push({ step: 'VALIDATION_WARNING', message: `Image placeholders: wanted ${config.imagesCount}, got ${placeholderMatches.length}` });\n    }\n  }\n  return errors;\n}\n\nasync function generateImage(prompt) {\n  for (const provider of config.imageProvider) {\n    try {\n      let img = null;\n      if (provider === 'openai' && config.openaiKey) {\n        img = await generateImageOpenAI.call(this, prompt);\n      } else if (provider === 'fal' && config.falKey) {\n        img = await generateImageFal.call(this, prompt);\n      } else if (provider === 'pexels' && config.pexelsKey) {\n        img = await fetchImagePexels.call(this, prompt);\n      }\n      if (img) {\n        debug.images_by_provider[provider] = (debug.images_by_provider[provider] || 0) + 1;\n        return { ...img, provider };\n      }\n    } catch (e) {\n      debug.image_errors.push({ provider, prompt: prompt.substring(0, 50), error: e.message });\n    }\n  }\n  return null;\n}\n\n// v2.23: OpenAI - use 512x512 to avoid memory issues on n8n Cloud\nasync function generateImageOpenAI(prompt) {\n  // DALL-E 2 supports: 256x256, 512x512, 1024x1024\n  // DALL-E 3 only supports: 1024x1024, 1024x1792, 1792x1024\n  const isDalle3 = config.openaiImageModel === 'dall-e-3';\n  const imageSize = isDalle3 ? '1024x1024' : '512x512'; // Smaller for DALL-E 2\n  \n  const resp = await httpRequest.call(this, {\n    method: 'POST',\n    url: 'https://api.openai.com/v1/images/generations',\n    headers: { 'Authorization': `Bearer ${config.openaiKey}`, 'Content-Type': 'application/json' },\n    body: {\n      model: config.openaiImageModel,\n      prompt: `Professional blog image: ${prompt}`,\n      n: 1,\n      size: imageSize,\n      response_format: 'b64_json'\n    },\n    timeout: 60000\n  });\n  const b64 = resp?.data?.[0]?.b64_json;\n  if (b64) return { base64: b64, mimeType: 'image/png', provider: 'openai' };\n  return null;\n}\n\n// fal.ai - model configurable per-site: fal-ai/flux/schnell, fal-ai/flux/dev, fal-ai/fast-sdxl\nasync function generateImageFal(prompt) {\n  const resp = await httpRequest.call(this, {\n    method: 'POST',\n    url: `https://fal.run/${config.falModel}`,\n    headers: { \n      'Authorization': `Key ${config.falKey}`, \n      'Content-Type': 'application/json' \n    },\n    body: {\n      prompt: `Professional blog image: ${prompt}`,\n      image_size: 'landscape_16_9',\n      num_images: 1\n    },\n    timeout: 60000\n  });\n  const imageUrl = resp?.images?.[0]?.url;\n  if (imageUrl) return { url: imageUrl };\n  return null;\n}\n\nasync function fetchImagePexels(query) {\n  const resp = await httpRequest.call(this, {\n    method: 'GET',\n    url: `https://api.pexels.com/v1/search?query=${encodeURIComponent(query)}&per_page=5`,\n    headers: { 'Authorization': config.pexelsKey }\n  });\n  const photos = resp?.photos || [];\n  if (photos.length > 0) {\n    const photo = photos[Math.floor(Math.random() * photos.length)];\n    return { url: photo.src?.large || photo.src?.original };\n  }\n  return null;\n}\n\nasync function uploadImageToWp(imageData, filename, altText) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  \n  // v2.27: Use custom n8n-image-upload plugin endpoints\n  // These accept JSON (not binary) so Cloudflare won't block them\n  \n  const ext = (imageData.mimeType || 'image/png').includes('png') ? 'png' : \n              (imageData.mimeType || '').includes('webp') ? 'webp' : 'jpg';\n  const fname = `${filename}.${ext}`;\n  \n  // For base64 images (OpenAI) - use /n8n/v1/upload-image\n  if (imageData.base64) {\n    const magicBytes = Buffer.from(imageData.base64, 'base64').slice(0, 4).toString('hex');\n    debug.image_errors.push({ \n      step: 'TRYING_N8N_PLUGIN_BASE64', \n      filename: fname,\n      magic_bytes: magicBytes,\n      base64_length: imageData.base64.length\n    });\n    \n    try {\n      const uploadResp = await httpRequest.call(this, {\n        method: 'POST',\n        url: `${config.baseUrl}/wp-json/n8n/v1/upload-image`,\n        headers: {\n          ...authHeaders,\n          'Content-Type': 'application/json'\n        },\n        body: {\n          base64: imageData.base64,\n          filename: fname,\n          mime_type: imageData.mimeType || 'image/png',\n          alt_text: altText || filename,\n          title: altText || filename\n        },\n        timeout: 45000\n      });\n      \n      if (uploadResp?.id || uploadResp?.success) {\n        debug.image_errors.push({ step: 'N8N_PLUGIN_SUCCESS', id: uploadResp.id, url: uploadResp.url });\n        return { id: uploadResp.id, url: uploadResp.url || uploadResp.source_url };\n      }\n      debug.image_errors.push({ step: 'N8N_PLUGIN_NO_ID', response: JSON.stringify(uploadResp || {}).substring(0, 300) });\n    } catch (e) {\n      const errMsg = e.message || '';\n      debug.image_errors.push({ step: 'N8N_PLUGIN_FAILED', error: errMsg.substring(0, 200) });\n      \n      // If plugin not installed, fall back to standard upload\n      if (errMsg.includes('rest_no_route') || errMsg.includes('404')) {\n        debug.image_errors.push({ step: 'PLUGIN_NOT_INSTALLED', hint: 'Install n8n-image-upload.php plugin' });\n      }\n    }\n  }\n  \n  // For URL images (fal, pexels) - use /n8n/v1/sideload-image\n  if (imageData.url) {\n    debug.image_errors.push({ step: 'TRYING_N8N_PLUGIN_SIDELOAD', url: imageData.url?.substring(0, 80) });\n    \n    try {\n      const sideloadResp = await httpRequest.call(this, {\n        method: 'POST',\n        url: `${config.baseUrl}/wp-json/n8n/v1/sideload-image`,\n        headers: {\n          ...authHeaders,\n          'Content-Type': 'application/json'\n        },\n        body: {\n          url: imageData.url,\n          filename: fname,\n          alt_text: altText || filename,\n          title: altText || filename\n        },\n        timeout: 45000\n      });\n      \n      if (sideloadResp?.id || sideloadResp?.success) {\n        debug.image_errors.push({ step: 'SIDELOAD_SUCCESS', id: sideloadResp.id, url: sideloadResp.url });\n        return { id: sideloadResp.id, url: sideloadResp.url || sideloadResp.source_url };\n      }\n      debug.image_errors.push({ step: 'SIDELOAD_NO_ID', response: JSON.stringify(sideloadResp || {}).substring(0, 200) });\n    } catch (e) {\n      const errMsg = e.message || '';\n      debug.image_errors.push({ step: 'SIDELOAD_FAILED', error: errMsg.substring(0, 200) });\n      \n      // Plugin not installed - use external URL as fallback\n      if (errMsg.includes('rest_no_route') || errMsg.includes('404')) {\n        debug.image_errors.push({ step: 'PLUGIN_NOT_INSTALLED_SIDELOAD' });\n      }\n    }\n    \n    // Fallback: Use external URL directly\n    debug.image_errors.push({ step: 'USING_EXTERNAL_URL', url: imageData.url?.substring(0, 80) });\n    return { id: null, url: imageData.url, external: true };\n  }\n  \n  return null;\n}\n\nasync function processImagePlaceholders(contentHtml, titleSlug) {\n  const placeholderRegex = /<!-- WPIMG alt=\"([^\"]+)\" -->/g;\n  let matches = [...contentHtml.matchAll(placeholderRegex)];\n  let featuredImageId = null;\n  let processedHtml = contentHtml;\n  const domain = config.baseUrl.replace(/https?:\\/\\//, '').replace(/\\/$/, '');\n  \n  // v2.40: Detect if AI stacked all placeholders together (within 500 chars of each other)\n  if (matches.length > 1) {\n    const positions = matches.map(m => m.index);\n    const maxGap = Math.max(...positions.slice(1).map((p, i) => p - positions[i]));\n    const contentLength = contentHtml.length;\n    const expectedMinGap = contentLength / (matches.length + 1) * 0.3; // Should be at least 30% of expected spacing\n    \n    if (maxGap < expectedMinGap || maxGap < 500) {\n      // Placeholders are clustered - redistribute using H2 sections\n      debug.wp_errors.push({ step: 'IMAGE_PLACEHOLDERS', message: 'AI stacked placeholders, redistributing by H2' });\n      \n      // Remove all existing placeholders\n      processedHtml = processedHtml.replace(placeholderRegex, '');\n      \n      // Find H2 positions for distribution\n      const h2Matches = [...processedHtml.matchAll(/<\\/h2>/gi)];\n      if (h2Matches.length >= matches.length) {\n        const step = Math.floor(h2Matches.length / (matches.length + 1));\n        for (let i = 0; i < matches.length; i++) {\n          const h2Index = Math.min((i + 1) * step, h2Matches.length - 1);\n          const h2Match = h2Matches[h2Index];\n          if (h2Match) {\n            const insertPos = h2Match.index + 5;\n            const placeholder = matches[i][0];\n            processedHtml = processedHtml.slice(0, insertPos) + '\\n\\n' + placeholder + '\\n\\n' + processedHtml.slice(insertPos);\n            // Re-find H2 matches since we modified the string\n          }\n        }\n        // Re-match placeholders after redistribution\n        matches = [...processedHtml.matchAll(placeholderRegex)];\n      }\n    }\n  }\n  \n  for (let i = 0; i < Math.min(matches.length, config.imagesCount); i++) {\n    const match = matches[i];\n    const altText = match[1];\n    const img = await generateImage.call(this, altText);\n    if (img) {\n      const uploaded = await uploadImageToWp.call(this, img, `${titleSlug}-${i + 1}`, altText);\n      if (uploaded) {\n        debug.images_uploaded++;\n        // v2.13: Handle both WP-uploaded and external URLs\n        const imgUrl = uploaded.url;\n        const imgHtml = uploaded.external \n          ? `<figure class=\"wp-block-image\"><img src=\"${imgUrl}\" alt=\"${altText}\" loading=\"lazy\" /></figure>`\n          : `<figure class=\"wp-block-image\"><img src=\"${imgUrl}\" alt=\"${altText} | ${domain}\" loading=\"lazy\" /></figure>`;\n        processedHtml = processedHtml.replace(match[0], imgHtml);\n        // Only set featured image if actually uploaded to WP\n        if (i === 0 && uploaded.id) featuredImageId = uploaded.id;\n        if (uploaded.external) {\n          debug.image_errors.push({ step: 'USING_EXTERNAL_URL', url: imgUrl.substring(0, 80) });\n        }\n      } else {\n        processedHtml = processedHtml.replace(match[0], '');\n      }\n    } else {\n      processedHtml = processedHtml.replace(match[0], '');\n    }\n  }\n  processedHtml = processedHtml.replace(placeholderRegex, '');\n  return { html: processedHtml, featuredImageId };\n}\n\n// v2.28: Helper to check if a phrase is inside a heading tag\nfunction isInsideHeading(content, phrase) {\n  const escapedPhrase = phrase.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  // Check if phrase appears inside any h1-h6 tag\n  const headingRegex = new RegExp(`<h[1-6][^>]*>[^<]*${escapedPhrase}[^<]*</h[1-6]>`, 'i');\n  return headingRegex.test(content);\n}\n\n// v2.28: Only match phrases inside paragraph or list content (not headings)\nfunction findSafeLinkPosition(content, phrase) {\n  const escapedPhrase = phrase.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  // Match phrase only when inside <p>, <li>, <td> tags (NOT in headings)\n  const safeContextRegex = new RegExp(\n    `(<(?:p|li|td)[^>]*>[^<]*?)(\\\\b${escapedPhrase}\\\\b)([^<]*?</(?:p|li|td)>)`,\n    'i'\n  );\n  return safeContextRegex.test(content) ? safeContextRegex : null;\n}\n\nasync function injectInternalLinks(content, anchorPhrases) {\n  if (config.internalLinksCount === 0 || !anchorPhrases?.length) return content;\n  const authHeaders = await getWpAuthHeaders.call(this);\n  let modifiedContent = content;\n  let inserted = 0;\n  const shuffled = [...anchorPhrases].sort(() => Math.random() - 0.5);\n  \n  for (const phrase of shuffled) {\n    if (inserted >= config.internalLinksCount) break;\n    // v2.28: Skip if phrase is inside a heading\n    if (isInsideHeading(modifiedContent, phrase)) continue;\n    \n    const escapedPhrase = phrase.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const inLinkRegex = new RegExp(`<a[^>]*>[^<]*${escapedPhrase}[^<]*</a>`, 'i');\n    // v2.28: Only match inside p, li, td tags\n    const safeRegex = new RegExp(\n      `(<(?:p|li|td)[^>]*>[^<]*?)(\\\\b${escapedPhrase}\\\\b)([^<]*?</(?:p|li|td)>)`,\n      'i'\n    );\n    if (!safeRegex.test(modifiedContent) || inLinkRegex.test(modifiedContent)) continue;\n    try {\n      const searchResp = await httpRequest.call(this, {\n        method: 'GET',\n        url: `${config.baseUrl}/wp-json/wp/v2/posts?search=${encodeURIComponent(phrase)}&per_page=5&status=publish`,\n        headers: authHeaders\n      });\n      if (searchResp?.length > 0) {\n        const post = searchResp[0];\n        modifiedContent = modifiedContent.replace(safeRegex, `$1<a href=\"${post.link}\">$2</a>$3`);\n        inserted++;\n      }\n    } catch (e) {}\n  }\n  debug.internal_links_inserted = inserted;\n  return modifiedContent;\n}\n\nfunction injectExternalLinks(content, anchorPhrases, serpResults) {\n  if (config.externalLinksCount === 0 || !serpResults?.length) return content;\n  let modifiedContent = content;\n  let inserted = 0;\n  const usedUrls = new Set();\n  const shuffledPhrases = [...(anchorPhrases || [])].sort(() => Math.random() - 0.5);\n  const shuffledSerp = [...serpResults].sort(() => Math.random() - 0.5);\n  \n  for (const phrase of shuffledPhrases) {\n    if (inserted >= config.externalLinksCount) break;\n    // v2.28: Skip if phrase is inside a heading\n    if (isInsideHeading(modifiedContent, phrase)) continue;\n    \n    const escapedPhrase = phrase.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const inLinkRegex = new RegExp(`<a[^>]*>[^<]*${escapedPhrase}[^<]*</a>`, 'i');\n    // v2.28: Only match inside p, li, td tags\n    const safeRegex = new RegExp(\n      `(<(?:p|li|td)[^>]*>[^<]*?)(\\\\b${escapedPhrase}\\\\b)([^<]*?</(?:p|li|td)>)`,\n      'i'\n    );\n    if (!safeRegex.test(modifiedContent) || inLinkRegex.test(modifiedContent)) continue;\n    const serpItem = shuffledSerp.find(s => !usedUrls.has(s.url));\n    if (serpItem) {\n      modifiedContent = modifiedContent.replace(safeRegex, `$1<a href=\"${serpItem.url}\" target=\"_blank\" rel=\"noopener\">$2</a>$3`);\n      usedUrls.add(serpItem.url);\n      inserted++;\n    }\n  }\n  \n  // Contextual fallback: find phrases from SERP results that naturally appear in content\n  // v2.12: Try 2-3 word phrases first, then fall back to single words\n  if (inserted < config.externalLinksCount) {\n    const availableSerp = shuffledSerp.filter(s => !usedUrls.has(s.url));\n    const skipWords = ['about', 'their', 'there', 'these', 'those', 'which', 'would', 'could', 'should', 'being', 'after', 'before', 'between', 'through', 'during', 'without', 'within', 'learn', 'click', 'here', 'best', 'guide', 'review', 'ultimate'];\n    \n    // Helper to extract n-grams from title\n    function extractNgrams(title, n) {\n      const words = title.split(/[^a-zA-Z0-9]+/).filter(w => w.length >= 3);\n      const ngrams = [];\n      for (let i = 0; i <= words.length - n; i++) {\n        const phrase = words.slice(i, i + n).join(' ');\n        // Skip if any word is a stop word\n        const phraseWords = phrase.toLowerCase().split(' ');\n        if (!phraseWords.some(w => skipWords.includes(w))) {\n          ngrams.push(phrase);\n        }\n      }\n      return ngrams;\n    }\n    \n    for (const serpItem of availableSerp) {\n      if (inserted >= config.externalLinksCount) break;\n      let matched = false;\n      \n      // Try 3-word phrases first\n      const trigrams = extractNgrams(serpItem.title, 3);\n      for (const phrase of trigrams) {\n        // v2.28: Skip if in heading\n        if (isInsideHeading(modifiedContent, phrase)) continue;\n        \n        const escaped = phrase.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, '\\\\\\\\$&');\n        const inLinkRegex = new RegExp(`<a[^>]*>[^<]*${escaped}[^<]*</a>`, 'i');\n        const safeRegex = new RegExp(\n          `(<(?:p|li|td)[^>]*>[^<]*?)(\\\\b${escaped}\\\\b)([^<]*?</(?:p|li|td)>)`,\n          'i'\n        );\n        if (safeRegex.test(modifiedContent) && !inLinkRegex.test(modifiedContent)) {\n          modifiedContent = modifiedContent.replace(safeRegex, `$1<a href=\"${serpItem.url}\" target=\"_blank\" rel=\"noopener\">$2</a>$3`);\n          usedUrls.add(serpItem.url);\n          inserted++;\n          matched = true;\n          break;\n        }\n      }\n      if (matched) continue;\n      \n      // Try 2-word phrases\n      const bigrams = extractNgrams(serpItem.title, 2);\n      for (const phrase of bigrams) {\n        if (isInsideHeading(modifiedContent, phrase)) continue;\n        \n        const escaped = phrase.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, '\\\\\\\\$&');\n        const inLinkRegex = new RegExp(`<a[^>]*>[^<]*${escaped}[^<]*</a>`, 'i');\n        const safeRegex = new RegExp(\n          `(<(?:p|li|td)[^>]*>[^<]*?)(\\\\b${escaped}\\\\b)([^<]*?</(?:p|li|td)>)`,\n          'i'\n        );\n        if (safeRegex.test(modifiedContent) && !inLinkRegex.test(modifiedContent)) {\n          modifiedContent = modifiedContent.replace(safeRegex, `$1<a href=\"${serpItem.url}\" target=\"_blank\" rel=\"noopener\">$2</a>$3`);\n          usedUrls.add(serpItem.url);\n          inserted++;\n          matched = true;\n          break;\n        }\n      }\n      if (matched) continue;\n      \n      // Fall back to single words (5+ chars)\n      const singleWords = serpItem.title.split(/[^a-zA-Z0-9]+/).filter(w => w.length >= 5 && !skipWords.includes(w.toLowerCase()));\n      for (const keyword of singleWords) {\n        if (isInsideHeading(modifiedContent, keyword)) continue;\n        \n        const inLinkRegex = new RegExp(`<a[^>]*>[^<]*${keyword}[^<]*</a>`, 'i');\n        const safeRegex = new RegExp(\n          `(<(?:p|li|td)[^>]*>[^<]*?)(\\\\b${keyword}\\\\b)([^<]*?</(?:p|li|td)>)`,\n          'i'\n        );\n        if (safeRegex.test(modifiedContent) && !inLinkRegex.test(modifiedContent)) {\n          modifiedContent = modifiedContent.replace(safeRegex, `$1<a href=\"${serpItem.url}\" target=\"_blank\" rel=\"noopener\">$2</a>$3`);\n          usedUrls.add(serpItem.url);\n          inserted++;\n          break;\n        }\n      }\n    }\n  }\n  debug.external_links_inserted = inserted;\n  return modifiedContent;\n}\n\n// v2.36: YouTube embeds placed by AI using <!-- YTVID context=\"...\" --> placeholders\nfunction injectYouTubeEmbeds(content, anchorPhrases, youtubeCandidates) {\n  if (config.youtubeCount === 0 || !youtubeCandidates?.length) return content;\n  let modifiedContent = content;\n  let inserted = 0;\n  const usedVideos = new Set();\n  const shuffledVideos = [...youtubeCandidates].sort(() => Math.random() - 0.5);\n  \n  // Find AI-placed YouTube placeholders\n  const placeholderRegex = /<!-- YTVID context=\"([^\"]+)\" -->/g;\n  const matches = [...content.matchAll(placeholderRegex)];\n  \n  // Replace placeholders with actual YouTube embeds\n  for (let i = 0; i < Math.min(matches.length, config.youtubeCount); i++) {\n    const match = matches[i];\n    const video = shuffledVideos.find(v => !usedVideos.has(v.videoId));\n    if (!video) break;\n    \n    const embedBlock = `\n\nhttps://www.youtube.com/watch?v=${video.videoId}\n\n<p style=\"text-align:center;font-style:italic;color:#666;margin-top:-10px;\">${video.title}</p>`;\n    \n    modifiedContent = modifiedContent.replace(match[0], embedBlock);\n    usedVideos.add(video.videoId);\n    inserted++;\n  }\n  \n  // Clean up any remaining placeholders\n  modifiedContent = modifiedContent.replace(/<!-- YTVID context=\"[^\"]+\" -->/g, '');\n  \n  // Fallback: if AI didn't place placeholders, use H2 distribution\n  if (inserted === 0 && matches.length === 0) {\n    debug.wp_errors.push({ step: 'YOUTUBE_PLACEHOLDERS', message: 'No AI placeholders found, using fallback distribution' });\n    const h2Matches = [...modifiedContent.matchAll(/<\\/h2>/gi)];\n    const totalSections = h2Matches.length;\n    \n    if (totalSections > 0) {\n      const embedCount = Math.min(config.youtubeCount, shuffledVideos.length, totalSections - 1);\n      const positions = [];\n      \n      if (embedCount === 1) {\n        positions.push(Math.floor(totalSections / 2));\n      } else {\n        const step = Math.floor((totalSections - 1) / (embedCount + 1));\n        for (let i = 1; i <= embedCount; i++) {\n          const pos = Math.min(i * step, totalSections - 1);\n          if (!positions.includes(pos)) positions.push(pos);\n        }\n      }\n      \n      positions.sort((a, b) => b - a);\n      \n      for (const sectionIndex of positions) {\n        if (inserted >= config.youtubeCount) break;\n        const video = shuffledVideos.find(v => !usedVideos.has(v.videoId));\n        if (!video) break;\n        \n        const h2Match = h2Matches[sectionIndex];\n        if (!h2Match) continue;\n        \n        const embedBlock = `\n\nhttps://www.youtube.com/watch?v=${video.videoId}\n\n<p style=\"text-align:center;font-style:italic;color:#666;margin-top:-10px;\">${video.title}</p>\n\n`;\n        \n        const pos = h2Match.index + 5;\n        modifiedContent = modifiedContent.slice(0, pos) + embedBlock + modifiedContent.slice(pos);\n        usedVideos.add(video.videoId);\n        inserted++;\n      }\n    }\n  }\n  \n  debug.youtube_embeds_inserted = inserted;\n  return modifiedContent;\n}\n\nasync function getOrCreateTags(tagString, tagSuggestions) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  let termNames = [];\n  if (tagString) {\n    termNames = tagString.split(/[,|]/).map(t => t.trim()).filter(t => t);\n  } else if (tagSuggestions?.length) {\n    termNames = tagSuggestions.slice(0, 5);\n  }\n  if (termNames.length === 0) return [];\n  const ids = [];\n  for (const name of termNames) {\n    try {\n      const searchResp = await httpRequest.call(this, {\n        method: 'GET',\n        url: `${config.baseUrl}/wp-json/wp/v2/tags?search=${encodeURIComponent(name)}`,\n        headers: authHeaders\n      });\n      const existing = (searchResp || []).find(t => t.name.toLowerCase() === name.toLowerCase());\n      if (existing) {\n        ids.push(existing.id);\n      } else {\n        const createResp = await httpRequest.call(this, {\n          method: 'POST',\n          url: `${config.baseUrl}/wp-json/wp/v2/tags`,\n          headers: { ...authHeaders, 'Content-Type': 'application/json' },\n          body: { name }\n        });\n        if (createResp?.id) ids.push(createResp.id);\n      }\n    } catch (e) {\n      debug.wp_errors.push({ step: 'CREATE_TAG', name, error: e.message });\n    }\n  }\n  return ids;\n}\n\nasync function getCategories(categoryString) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  let termNames = [];\n  if (categoryString) {\n    termNames = categoryString.split(/[,|]/).map(t => t.trim()).filter(t => t);\n  }\n  if (termNames.length === 0 && config.defaultCategory) {\n    termNames = [config.defaultCategory];\n  }\n  debug.categories_requested = termNames;\n  if (termNames.length === 0) return [];\n  const ids = [];\n  let allCategories = [];\n  try {\n    const catResp = await httpRequest.call(this, {\n      method: 'GET',\n      url: `${config.baseUrl}/wp-json/wp/v2/categories?per_page=100`,\n      headers: authHeaders\n    });\n    allCategories = catResp || [];\n  } catch (e) {\n    debug.wp_errors.push({ step: 'FETCH_CATEGORIES', error: e.message });\n    return [];\n  }\n  for (const name of termNames) {\n    const nameLower = name.toLowerCase();\n    const nameSlug = nameLower.replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n    let found = allCategories.find(c => c.name.toLowerCase() === nameLower);\n    if (!found) found = allCategories.find(c => c.slug === nameSlug);\n    if (!found) found = allCategories.find(c => c.name.toLowerCase().includes(nameLower) || nameLower.includes(c.name.toLowerCase()));\n    if (found) {\n      ids.push(found.id);\n      debug.categories_found.push({ requested: name, matched: found.name, id: found.id });\n    } else {\n      // v2.31: Auto-create category via plugin endpoint (bypasses REST API 403)\n      try {\n        const createResp = await httpRequest.call(this, {\n          method: 'POST',\n          url: `${config.baseUrl}/wp-json/n8n/v1/create-category`,\n          headers: { ...authHeaders, 'Content-Type': 'application/json' },\n          body: { name: name, slug: nameSlug }\n        });\n        if (createResp?.id) {\n          ids.push(createResp.id);\n          debug.categories_found.push({ requested: name, created: createResp.created !== false, id: createResp.id });\n        }\n      } catch (createErr) {\n        debug.wp_errors.push({ step: 'CREATE_CATEGORY', requested: name, error: createErr.message });\n      }\n    }\n  }\n  return ids;\n}\n\n// v2.29: Schema is handled by Yoast/RankMath plugins (WP blocks script tags in post content)\n// The faq_items are still generated for potential future use or plugin integration\n\n// v2.30: Update Yoast/RankMath SEO meta via custom plugin endpoint\nasync function updateSeoMeta(postId, contentJson) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  const focusKeyphrase = contentJson.focus_keyphrase || config.topic;\n  \n  // Try our custom n8n plugin endpoint first (uses update_post_meta directly)\n  try {\n    const seoResp = await httpRequest.call(this, {\n      method: 'POST',\n      url: `${config.baseUrl}/wp-json/n8n/v1/update-seo-meta`,\n      headers: { ...authHeaders, 'Content-Type': 'application/json' },\n      body: {\n        post_id: postId,\n        focus_keyphrase: focusKeyphrase,\n        meta_description: contentJson.meta_description,\n        seo_title: contentJson.title\n      }\n    });\n    debug.seo_meta_updated = seoResp?.updated || true;\n    debug.seo_plugins = seoResp?.seo_plugins || {};\n    return;\n  } catch (e) {\n    // Plugin endpoint not available, try REST API fallback\n    debug.seo_meta_updated = `plugin_not_found: ${e.message?.substring(0, 50)}`;\n  }\n  \n  // Fallback: Try standard REST API (may not work without registered meta)\n  try {\n    await httpRequest.call(this, {\n      method: 'POST',\n      url: `${config.baseUrl}/wp-json/wp/v2/posts/${postId}`,\n      headers: { ...authHeaders, 'Content-Type': 'application/json' },\n      body: {\n        meta: {\n          _yoast_wpseo_focuskw: focusKeyphrase,\n          _yoast_wpseo_metadesc: contentJson.meta_description,\n          rank_math_focus_keyword: focusKeyphrase,\n          rank_math_description: contentJson.meta_description\n        }\n      }\n    });\n    debug.seo_meta_updated = 'rest_api_fallback';\n  } catch (e) {\n    debug.seo_meta_updated = `failed: ${e.message?.substring(0, 50)}`;\n  }\n}\n\nasync function publishPost(postData) {\n  const authHeaders = await getWpAuthHeaders.call(this);\n  try {\n    const resp = await httpRequest.call(this, {\n      method: 'POST',\n      url: `${config.baseUrl}/wp-json/wp/v2/posts`,\n      headers: { ...authHeaders, 'Content-Type': 'application/json' },\n      body: postData\n    });\n    return resp;\n  } catch (e) {\n    debug.wp_errors.push({ step: 'PUBLISH', error: e.message, statusCode: e.response?.status, response: e.response?.data });\n    throw new Error(`WP POST failed: ${e.message}`);\n  }\n}\n\n// v2.8: Per-site SpeedyIndex control\nasync function pingSpeedyIndex(postUrl) {\n  if (!config.speedyindexEnabled) {\n    debug.notifications.speedyindex = 'disabled_for_site';\n    return false;\n  }\n  if (!config.speedyIndexKey) {\n    debug.notifications.speedyindex = 'no_api_key';\n    return false;\n  }\n  if (config.postStatus !== 'publish') {\n    debug.notifications.speedyindex = 'post_not_published';\n    return false;\n  }\n  try {\n    await httpRequest.call(this, {\n      method: 'POST',\n      url: 'https://api.speedyindex.com/v1/index',\n      headers: { 'Authorization': `Bearer ${config.speedyIndexKey}`, 'Content-Type': 'application/json' },\n      body: { url: postUrl }\n    });\n    debug.notifications.speedyindex = true;\n    return true;\n  } catch (e) {\n    debug.wp_errors.push({ step: 'SPEEDYINDEX', error: e.message });\n    debug.notifications.speedyindex = `error: ${e.message}`;\n    return false;\n  }\n}\n\n// v2.8: Per-site Telegram control\nasync function sendTelegramNotification(message) {\n  if (!config.telegramEnabled) {\n    debug.notifications.telegram = 'disabled_for_site';\n    return false;\n  }\n  if (!config.telegramToken || !config.telegramChatId) {\n    debug.notifications.telegram = 'no_credentials';\n    return false;\n  }\n  try {\n    await httpRequest.call(this, {\n      method: 'POST',\n      url: `https://api.telegram.org/bot${config.telegramToken}/sendMessage`,\n      headers: { 'Content-Type': 'application/json' },\n      body: { chat_id: config.telegramChatId, text: message, parse_mode: 'HTML' }\n    });\n    debug.notifications.telegram = true;\n    return true;\n  } catch (e) {\n    debug.wp_errors.push({ step: 'TELEGRAM', error: e.message });\n    debug.notifications.telegram = `error: ${e.message}`;\n    return false;\n  }\n}\n\n// v2.8: Per-site Email control\nasync function sendEmailNotification(subject, htmlBody) {\n  if (!config.emailEnabled) {\n    debug.notifications.email = 'disabled_for_site';\n    return false;\n  }\n  if (!config.notificationEmail) {\n    debug.notifications.email = 'no_recipient';\n    return false;\n  }\n  if (!config.emailProvider) {\n    debug.notifications.email = 'no_provider';\n    return false;\n  }\n  try {\n    switch (config.emailProvider) {\n      case 'resend':\n        if (!config.resendApiKey) { debug.notifications.email = 'no_resend_key'; return false; }\n        await httpRequest.call(this, {\n          method: 'POST', url: 'https://api.resend.com/emails',\n          headers: { 'Authorization': `Bearer ${config.resendApiKey}`, 'Content-Type': 'application/json' },\n          body: { from: config.emailFrom, to: config.notificationEmail, subject, html: htmlBody }\n        });\n        break;\n      case 'sendgrid':\n        if (!config.sendgridApiKey) { debug.notifications.email = 'no_sendgrid_key'; return false; }\n        await httpRequest.call(this, {\n          method: 'POST', url: 'https://api.sendgrid.com/v3/mail/send',\n          headers: { 'Authorization': `Bearer ${config.sendgridApiKey}`, 'Content-Type': 'application/json' },\n          body: { personalizations: [{ to: [{ email: config.notificationEmail }] }], from: { email: config.emailFrom }, subject, content: [{ type: 'text/html', value: htmlBody }] }\n        });\n        break;\n      case 'mailgun':\n        if (!config.mailgunApiKey || !config.mailgunDomain) { debug.notifications.email = 'no_mailgun_config'; return false; }\n        const formData = new URLSearchParams();\n        formData.append('from', config.emailFrom);\n        formData.append('to', config.notificationEmail);\n        formData.append('subject', subject);\n        formData.append('html', htmlBody);\n        await httpRequest.call(this, {\n          method: 'POST', url: `https://api.mailgun.net/v3/${config.mailgunDomain}/messages`,\n          headers: { 'Authorization': `Basic ${Buffer.from(`api:${config.mailgunApiKey}`).toString('base64')}`, 'Content-Type': 'application/x-www-form-urlencoded' },\n          body: formData.toString()\n        });\n        break;\n      case 'smtp2go':\n        if (!config.smtp2goApiKey) { debug.notifications.email = 'no_smtp2go_key'; return false; }\n        await httpRequest.call(this, {\n          method: 'POST', url: 'https://api.smtp2go.com/v3/email/send',\n          headers: { 'Content-Type': 'application/json' },\n          body: { api_key: config.smtp2goApiKey, sender: config.emailFrom, to: [config.notificationEmail], subject, html_body: htmlBody }\n        });\n        break;\n      default:\n        debug.notifications.email = `unknown_provider: ${config.emailProvider}`;\n        return false;\n    }\n    debug.notifications.email = true;\n    return true;\n  } catch (e) {\n    debug.wp_errors.push({ step: 'EMAIL', provider: config.emailProvider, error: e.message });\n    debug.notifications.email = `error: ${e.message}`;\n    return false;\n  }\n}\n\ntry {\n  currentStep = 'WP_AUTH_CHECK';\n  executionLog.push({ step: currentStep, status: 'started', time: new Date().toISOString() });\n  const authCheck = await wpAuthSanityCheck.call(this);\n  executionLog.push({ step: currentStep, status: 'completed', user: authCheck.user });\n  \n  currentStep = 'FETCH_HINTS';\n  executionLog.push({ step: currentStep, status: 'started' });\n  const [serpResults, youtubeCandidates] = await Promise.all([fetchSerpHints.call(this), fetchYouTubeCandidates.call(this)]);\n  executionLog.push({ step: currentStep, status: 'completed', serp: serpResults.length, youtube: youtubeCandidates.length });\n  \n  currentStep = 'GENERATE_CONTENT';\n  executionLog.push({ step: currentStep, status: 'started' });\n  const contentJson = await generateContentJson.call(this);\n  const validationErrors = validateContent(contentJson);\n  if (validationErrors.length > 0) throw new Error(`Content validation failed: ${validationErrors.join(', ')}`);\n  executionLog.push({ step: currentStep, status: 'completed', title: contentJson.title?.substring(0, 50) });\n  \n  currentStep = 'PROCESS_IMAGES';\n  let processedHtml = contentJson.content_html;\n  let featuredImageId = null;\n  if (config.imagesCount > 0) {\n    executionLog.push({ step: currentStep, status: 'started', count: config.imagesCount });\n    const titleSlug = contentJson.slug || contentJson.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').substring(0, 50);\n    const imgResult = await processImagePlaceholders.call(this, processedHtml, titleSlug);\n    processedHtml = imgResult.html;\n    featuredImageId = imgResult.featuredImageId;\n    executionLog.push({ step: currentStep, status: 'completed', uploaded: debug.images_uploaded, featuredId: featuredImageId });\n  } else {\n    executionLog.push({ step: currentStep, status: 'skipped', reason: 'images_count=0' });\n  }\n  \n  currentStep = 'INTERNAL_LINKS';\n  if (config.internalLinksCount > 0) {\n    executionLog.push({ step: currentStep, status: 'started' });\n    processedHtml = await injectInternalLinks.call(this, processedHtml, contentJson.internal_anchor_phrases);\n    executionLog.push({ step: currentStep, status: 'completed', inserted: debug.internal_links_inserted });\n  } else {\n    executionLog.push({ step: currentStep, status: 'skipped' });\n  }\n  \n  currentStep = 'EXTERNAL_LINKS';\n  if (config.externalLinksCount > 0 && serpResults.length > 0) {\n    executionLog.push({ step: currentStep, status: 'started' });\n    processedHtml = injectExternalLinks(processedHtml, contentJson.external_anchor_phrases, serpResults);\n    executionLog.push({ step: currentStep, status: 'completed', inserted: debug.external_links_inserted });\n  } else {\n    executionLog.push({ step: currentStep, status: 'skipped', reason: serpResults.length === 0 ? 'no SERP results' : 'disabled' });\n  }\n  \n  currentStep = 'YOUTUBE_EMBEDS';\n  if (config.youtubeCount > 0 && youtubeCandidates.length > 0) {\n    executionLog.push({ step: currentStep, status: 'started' });\n    processedHtml = injectYouTubeEmbeds(processedHtml, contentJson.youtube_anchor_phrases, youtubeCandidates);\n    executionLog.push({ step: currentStep, status: 'completed', inserted: debug.youtube_embeds_inserted });\n  } else {\n    executionLog.push({ step: currentStep, status: 'skipped' });\n  }\n  \n  currentStep = 'TERMS';\n  const [tagIds, categoryIds] = await Promise.all([getOrCreateTags.call(this, config.tags, contentJson.tag_suggestions), getCategories.call(this, config.categories)]);\n  executionLog.push({ step: currentStep, status: 'completed', tags: tagIds.length, categories: categoryIds.length, categoryDetails: debug.categories_found });\n  \n  currentStep = 'PUBLISH_POST';\n  executionLog.push({ step: currentStep, status: 'started' });\n  \n  // v2.29: Schema handled by Yoast/RankMath (WP blocks script tags in content)\n  const postData = {\n    title: contentJson.title,\n    slug: contentJson.slug,\n    content: processedHtml,\n    excerpt: contentJson.meta_description,\n    status: config.postStatus,\n    comment_status: 'open',\n    ping_status: 'open'\n  };\n  if (featuredImageId) postData.featured_media = featuredImageId;\n  if (tagIds.length > 0) postData.tags = tagIds;\n  if (categoryIds.length > 0) postData.categories = categoryIds;\n  const postResp = await publishPost.call(this, postData);\n  if (!postResp?.id) throw new Error('Failed to create WordPress post - no ID returned');\n  executionLog.push({ step: currentStep, status: 'completed', postId: postResp.id });\n  \n  currentStep = 'POST_PROCESSING';\n  \n  // v2.28: Update Yoast/RankMath SEO meta fields\n  await updateSeoMeta.call(this, postResp.id, contentJson);\n  \n  // SpeedyIndex (only for published posts, respects per-site setting)\n  await pingSpeedyIndex.call(this, postResp.link);\n  \n  // Telegram (respects per-site setting)\n  const notifyMessage = `\u2705 <b>New Post Published</b>\\n\\n\ud83d\udcdd ${contentJson.title}\\n\ud83c\udf10 ${site.site_name || config.baseUrl}\\n\ud83d\udd17 ${postResp.link || 'Draft'}\\n\ud83d\udcca Images: ${debug.images_uploaded}/${debug.images_requested}\\n\ud83d\udd17 Internal: ${debug.internal_links_inserted}/${debug.internal_links_requested}\\n\ud83c\udf10 External: ${debug.external_links_inserted}/${debug.external_links_requested}\\n\ud83d\udcfa YouTube: ${debug.youtube_embeds_inserted}/${debug.youtube_embeds_requested}\\n\ud83c\udff7\ufe0f Categories: ${categoryIds.length}`;\n  await sendTelegramNotification.call(this, notifyMessage);\n  \n  // Email (respects per-site setting)\n  const emailHtml = `<h2>\u2705 New Post Published</h2><p><strong>Site:</strong> ${site.site_name || config.baseUrl}</p><p><strong>Title:</strong> ${contentJson.title}</p><p><strong>URL:</strong> <a href=\"${postResp.link}\">${postResp.link || 'Draft'}</a></p><p><strong>Images:</strong> ${debug.images_uploaded}/${debug.images_requested}</p><p><strong>Internal Links:</strong> ${debug.internal_links_inserted}/${debug.internal_links_requested}</p><p><strong>External Links:</strong> ${debug.external_links_inserted}/${debug.external_links_requested}</p><p><strong>YouTube:</strong> ${debug.youtube_embeds_inserted}/${debug.youtube_embeds_requested}</p><p><strong>Categories:</strong> ${categoryIds.length}</p>`;\n  await sendEmailNotification.call(this, `New Post: ${contentJson.title}`, emailHtml);\n  \n  executionLog.push({ step: currentStep, status: 'completed', notifications: debug.notifications });\n  \n  return [{ json: { ok: true, post_id: postResp.id, post_url: postResp.link, title: contentJson.title, slug: contentJson.slug, focus_keyphrase: contentJson.focus_keyphrase, status: postResp.status, featured_image_id: featuredImageId, debug, execution_log: executionLog, site, topicRow } }];\n} catch (error) {\n  executionLog.push({ step: currentStep, status: 'FAILED', error: error.message });\n  \n  // Send failure notifications (still respects per-site settings)\n  const failMsg = `\u274c <b>Post Failed</b>\\n\\n\ud83d\udcdd ${config.topic}\\n\ud83c\udf10 ${site.site_name || config.baseUrl}\\n\ud83d\udeab Step: ${currentStep}\\n\u26a0\ufe0f ${error.message}`;\n  await sendTelegramNotification.call(this, failMsg).catch(() => {});\n  \n  const failEmailHtml = `<h2>\u274c Post Failed</h2><p><strong>Site:</strong> ${site.site_name || config.baseUrl}</p><p><strong>Topic:</strong> ${config.topic}</p><p><strong>Step:</strong> ${currentStep}</p><p><strong>Error:</strong> ${error.message}</p>`;\n  await sendEmailNotification.call(this, `FAILED: ${config.topic}`, failEmailHtml).catch(() => {});\n  \n  return [{ json: { ok: false, error: error.message, failed_at_step: currentStep, debug, execution_log: executionLog, stack: error.stack, site, topicRow } }];\n}\n"
      },
      "id": "engine-001",
      "name": "Publisher Engine (Code)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        440,
        0
      ]
    }
  ],
  "connections": {
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Inject Globals",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Inject Globals": {
      "main": [
        [
          {
            "node": "Publisher Engine (Code)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "v2.40-auto-distribute",
  "meta": {
    "templateId": "autoblogger-publisher-v2.8"
  },
  "tags": []
}